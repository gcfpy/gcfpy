{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Graphical Curve Fit for Python gcfpy is a graphical application for building, executing, and analyzing curve fitting workflows. Designed for scientists and engineers, it provides an interactive environment for fitting experimental data using user-defined models. You can define models using a formula interface based on SymPy syntax, fit data using least-squares ( lmfit ), Bayes ian methods ( emcee ) or orthogonal distance regression ( scipy ), and compare multiple fits. Key Features Define custom models using symbolic formulas Fit using least-squares (lmfit), orthogonal distance regression (scipy.odr), or MCMC (emcee) Visualise residuals, confidence bands, and component contributions Run and compare multiple fits in parallel tabs Adjust parameters manually and explore model behavior Import/export data and fit results (CSV) The gcfpy package is free software, using an Open Source license. The software and this document are works in progress. If you are interested in participating in this effort please use the Git repository . User guide Getting started : How to begin using the application Installation : Instructions for installing gcfpy and required dependencies Getting Help : Where to look when you're stuck Tutorials Basic fit : Start with a simple 1D fit using a basic formula on noisy data. Plots lmfit/odr : Explore confidence bands, residuals, decomposition, and 2D contour plots (for non-MCMC methods). Plots mcmc : Run a full MCMC fit and visualize results with corner, walkers, autocorrelation, and 99% bands. Multi 1D fit : Perform 1D fits across slices of Y in a 2D dataset (Z = f(X), Y fixed), with a global formula including y . 2D fit : Fit a full surface model Z = f(X, Y), using 2D plotting, surface rendering, and projections. Manual fit : Manually adjust parameters using sliders and observe the live response. Comparison : Store, toggle, and compare multiple fits using the integrated comparison tool. Application Sections UI Overview : Introduction to the interface layout and navigation Menus : File, view, and advanced menu actions Toolbar : Quick-access actions for fitting, plotting, and toggles Docks : Modular panels for formulas, plots, results, and data inspection Model Definition & Execution Formula Editor : Writing and importing formulas using SymPy/NumPy syntax Fit Options : Customizing method, bounds, initial values, and strategy Manual Fit : Interactive sliders for manual parameter adjustment Comparison Mode : Save and compare multiple fits Fit result : View numerical fit reports and graphical diagnostics (residuals, decomposition, etc.) MCMC result : corner plots, autocorrelation diagnostics, uncertainty intervals Working with Data Load Data : Supported formats and loading mechanisms (CSV) Add Custom Loaders : Extend data input with custom logic Developpment Overview : Supported formats and loading mechanisms (CSV) FitTab : Main workspace for fitting operations and data handling Toolbar : Toolbar setup, menus, and action handling Fit Control : Fit parameter selection and orchestration Fit Processor : Core fitting logic (lmfit, odr, emcee) Fit Comparison : Manage, display, and export multiple fits Plot System : 1D, 2D, an mcmc More Information Dependencies : PyQt5 , lmfit , emcee , scipy , pandas , numpy , matplotlib Source code : Git repository License : MIT License","title":"Home"},{"location":"#graphical-curve-fit-for-python","text":"gcfpy is a graphical application for building, executing, and analyzing curve fitting workflows. Designed for scientists and engineers, it provides an interactive environment for fitting experimental data using user-defined models. You can define models using a formula interface based on SymPy syntax, fit data using least-squares ( lmfit ), Bayes ian methods ( emcee ) or orthogonal distance regression ( scipy ), and compare multiple fits.","title":"Graphical Curve Fit for Python"},{"location":"#key-features","text":"Define custom models using symbolic formulas Fit using least-squares (lmfit), orthogonal distance regression (scipy.odr), or MCMC (emcee) Visualise residuals, confidence bands, and component contributions Run and compare multiple fits in parallel tabs Adjust parameters manually and explore model behavior Import/export data and fit results (CSV) The gcfpy package is free software, using an Open Source license. The software and this document are works in progress. If you are interested in participating in this effort please use the Git repository .","title":"Key Features"},{"location":"#user-guide","text":"Getting started : How to begin using the application Installation : Instructions for installing gcfpy and required dependencies Getting Help : Where to look when you're stuck","title":"User guide"},{"location":"#tutorials","text":"Basic fit : Start with a simple 1D fit using a basic formula on noisy data. Plots lmfit/odr : Explore confidence bands, residuals, decomposition, and 2D contour plots (for non-MCMC methods). Plots mcmc : Run a full MCMC fit and visualize results with corner, walkers, autocorrelation, and 99% bands. Multi 1D fit : Perform 1D fits across slices of Y in a 2D dataset (Z = f(X), Y fixed), with a global formula including y . 2D fit : Fit a full surface model Z = f(X, Y), using 2D plotting, surface rendering, and projections. Manual fit : Manually adjust parameters using sliders and observe the live response. Comparison : Store, toggle, and compare multiple fits using the integrated comparison tool.","title":"Tutorials"},{"location":"#application-sections","text":"UI Overview : Introduction to the interface layout and navigation Menus : File, view, and advanced menu actions Toolbar : Quick-access actions for fitting, plotting, and toggles Docks : Modular panels for formulas, plots, results, and data inspection","title":"Application Sections"},{"location":"#model-definition-execution","text":"Formula Editor : Writing and importing formulas using SymPy/NumPy syntax Fit Options : Customizing method, bounds, initial values, and strategy Manual Fit : Interactive sliders for manual parameter adjustment Comparison Mode : Save and compare multiple fits Fit result : View numerical fit reports and graphical diagnostics (residuals, decomposition, etc.) MCMC result : corner plots, autocorrelation diagnostics, uncertainty intervals","title":"Model Definition &amp; Execution"},{"location":"#working-with-data","text":"Load Data : Supported formats and loading mechanisms (CSV) Add Custom Loaders : Extend data input with custom logic","title":"Working with Data"},{"location":"#developpment","text":"Overview : Supported formats and loading mechanisms (CSV) FitTab : Main workspace for fitting operations and data handling Toolbar : Toolbar setup, menus, and action handling Fit Control : Fit parameter selection and orchestration Fit Processor : Core fitting logic (lmfit, odr, emcee) Fit Comparison : Manage, display, and export multiple fits Plot System : 1D, 2D, an mcmc","title":"Developpment"},{"location":"#more-information","text":"Dependencies : PyQt5 , lmfit , emcee , scipy , pandas , numpy , matplotlib Source code : Git repository License : MIT License","title":"More Information"},{"location":"data/custom_data_loader/","text":"Adding a Custom Data Loader This guide explains how to integrate a new data loading method into the application, in addition to the built-in CSV and HDF5 readers. 1. When to Customize You may want to implement a custom loader when dealing with: JSON files Excel spreadsheets Proprietary binary formats Direct connections to databases or instruments 2. Where to Modify The DataLoader class handles all file loading operations and is located in: gcfpy/utils/data_loader.py 3. Implementing a New Loader Step 1 \u2014 Add a Method Define a new method in the DataLoader class: def load_json_format(self, file_path): try: import json with open(file_path, \"r\") as f: data = json.load(f) df = pd.DataFrame({\"X\": data[\"X\"], \"Y\": data[\"Y\"]}) return df except Exception as e: self.show_error_message(f\"Failed to load JSON: {e}\") return None Make sure your method returns a pandas.DataFrame with columns X and Y (and optionally Z , X_err , Y_err ). Step 2 \u2014 Register the Extension Update the main read_file() method to detect and dispatch based on the file extension: if file_name.endswith(\".json\"): self.df = self.load_json_format(file_name) You may also update the file dialog to list .json as a supported extension if needed. 4. No Further Changes Needed Once your custom loader returns a valid DataFrame: The X/Y table will be populated The data will appear in the plot The fit panel and toolbar will be enabled No need to modify any part of the fitting or visualization pipeline.","title":"Add Custom Loader"},{"location":"data/custom_data_loader/#adding-a-custom-data-loader","text":"This guide explains how to integrate a new data loading method into the application, in addition to the built-in CSV and HDF5 readers.","title":"Adding a Custom Data Loader"},{"location":"data/custom_data_loader/#1-when-to-customize","text":"You may want to implement a custom loader when dealing with: JSON files Excel spreadsheets Proprietary binary formats Direct connections to databases or instruments","title":"1. When to Customize"},{"location":"data/custom_data_loader/#2-where-to-modify","text":"The DataLoader class handles all file loading operations and is located in: gcfpy/utils/data_loader.py","title":"2. Where to Modify"},{"location":"data/custom_data_loader/#3-implementing-a-new-loader","text":"","title":"3. Implementing a New Loader"},{"location":"data/custom_data_loader/#step-1-add-a-method","text":"Define a new method in the DataLoader class: def load_json_format(self, file_path): try: import json with open(file_path, \"r\") as f: data = json.load(f) df = pd.DataFrame({\"X\": data[\"X\"], \"Y\": data[\"Y\"]}) return df except Exception as e: self.show_error_message(f\"Failed to load JSON: {e}\") return None Make sure your method returns a pandas.DataFrame with columns X and Y (and optionally Z , X_err , Y_err ).","title":"Step 1 \u2014 Add a Method"},{"location":"data/custom_data_loader/#step-2-register-the-extension","text":"Update the main read_file() method to detect and dispatch based on the file extension: if file_name.endswith(\".json\"): self.df = self.load_json_format(file_name) You may also update the file dialog to list .json as a supported extension if needed.","title":"Step 2 \u2014 Register the Extension"},{"location":"data/custom_data_loader/#4-no-further-changes-needed","text":"Once your custom loader returns a valid DataFrame: The X/Y table will be populated The data will appear in the plot The fit panel and toolbar will be enabled No need to modify any part of the fitting or visualization pipeline.","title":"4. No Further Changes Needed"},{"location":"data/data_loader/","text":"Data Loader The DataLoader class handles the import and validation of user-provided data files before they are passed to the application\u2019s visualization and fitting components. Responsibilities Open files using a dialog or programmatic input Read and validate .csv content Ensure required columns ( X , Y ) are present Reject malformed or incomplete data Return a clean pandas.DataFrame for downstream use Supported Formats .csv (standard) Custom loaders can be added (see Custom Loader Guide ) Main Methods load_data(file_name=None) Opens a file dialog (if file_name is not passed) Dispatches to the appropriate read method On success, returns a validated DataFrame and the file path read_csv(file_path) Uses pandas.read_csv() to load file Validates presence of X and Y columns Checks for NaNs or non-numeric values show_error_message(message) Uses QMessageBox to inform the user of errors (e.g., missing columns or invalid format) Typical Integration df, file_path = data_loader.load_data() if df is not None: tab.load_data_into_tab(df, file_path) Once the data is loaded: The table view ( X/Y Data ) is updated The main plot is refreshed Toolbar actions are enabled Fit controls become accessible","title":"Load Data"},{"location":"data/data_loader/#data-loader","text":"The DataLoader class handles the import and validation of user-provided data files before they are passed to the application\u2019s visualization and fitting components.","title":"Data Loader"},{"location":"data/data_loader/#responsibilities","text":"Open files using a dialog or programmatic input Read and validate .csv content Ensure required columns ( X , Y ) are present Reject malformed or incomplete data Return a clean pandas.DataFrame for downstream use","title":"Responsibilities"},{"location":"data/data_loader/#supported-formats","text":".csv (standard) Custom loaders can be added (see Custom Loader Guide )","title":"Supported Formats"},{"location":"data/data_loader/#main-methods","text":"","title":"Main Methods"},{"location":"data/data_loader/#load_datafile_namenone","text":"Opens a file dialog (if file_name is not passed) Dispatches to the appropriate read method On success, returns a validated DataFrame and the file path","title":"load_data(file_name=None)"},{"location":"data/data_loader/#read_csvfile_path","text":"Uses pandas.read_csv() to load file Validates presence of X and Y columns Checks for NaNs or non-numeric values","title":"read_csv(file_path)"},{"location":"data/data_loader/#show_error_messagemessage","text":"Uses QMessageBox to inform the user of errors (e.g., missing columns or invalid format)","title":"show_error_message(message)"},{"location":"data/data_loader/#typical-integration","text":"df, file_path = data_loader.load_data() if df is not None: tab.load_data_into_tab(df, file_path) Once the data is loaded: The table view ( X/Y Data ) is updated The main plot is refreshed Toolbar actions are enabled Fit controls become accessible","title":"Typical Integration"},{"location":"dev/fit_comparison/","text":"FitComparisonManager This class handles the storage, display, and export of multiple fitting results for comparison. It is used from within a FitTab to enable model benchmarking and result visualization. Role in the Application Attached to each FitTab instance. Activated via the toolbar (\"Compare\" action). Stores all fit results (only 1D). Provides a dock with: A matplotlib plot showing all selected models A table listing fit parameters and scores A list to rename, enable/disable individual fits A CSV export button Comparison Flow flowchart TD FTab[FitTab] FTab -->|calls| Comp[FitComparisonManager] Comp -->|store| Store[stored_fits] Comp -->|display| Dock[Comparison Dock] Dock --> PlotComp[Comparison Plot] Dock --> TableComp[Comparison Table] Stored Data Each entry in stored_fits is a dict containing: { \"formula\": str, \"method\": str, # \"lmfit\", \"odr\", \"emcee\" \"params\": lmfit.Parameters or dict, \"aic\": float, \"bic\": float, \"rmse\": float, \"r_squared\": float, \"chi_square\": float, \"reduced_chi_square\": float, } Supported Strategies 1D Fit: Overlays different model predictions on a scatter plot of X, Y . Fit per Y (multi-1D): Recomputes predictions for each Y slice, plots curves on X, Z . Key Methods Method Description store_current_fit() Saves the current model result to internal list toggle_comparison_mode() Shows/hides the comparison interface create_comparison_ui() Builds dock with plot, list, table, and export button redraw_comparison_plot() Redraws model predictions over data depending on selected fits export_comparison_csv() Saves all stored results to a CSV file reset() Clears all stored data and disables comparison mode Dependencies Requires fit_tab.plot_widget.result to be set. Uses parse_formula() to dynamically recreate fit functions for plotting. Compatible with both lmfit.ModelResult and custom dicts from emcee / odr .","title":"Fit Comparison"},{"location":"dev/fit_comparison/#fitcomparisonmanager","text":"This class handles the storage, display, and export of multiple fitting results for comparison. It is used from within a FitTab to enable model benchmarking and result visualization.","title":"FitComparisonManager"},{"location":"dev/fit_comparison/#role-in-the-application","text":"Attached to each FitTab instance. Activated via the toolbar (\"Compare\" action). Stores all fit results (only 1D). Provides a dock with: A matplotlib plot showing all selected models A table listing fit parameters and scores A list to rename, enable/disable individual fits A CSV export button","title":"Role in the Application"},{"location":"dev/fit_comparison/#comparison-flow","text":"flowchart TD FTab[FitTab] FTab -->|calls| Comp[FitComparisonManager] Comp -->|store| Store[stored_fits] Comp -->|display| Dock[Comparison Dock] Dock --> PlotComp[Comparison Plot] Dock --> TableComp[Comparison Table]","title":"Comparison Flow"},{"location":"dev/fit_comparison/#stored-data","text":"Each entry in stored_fits is a dict containing: { \"formula\": str, \"method\": str, # \"lmfit\", \"odr\", \"emcee\" \"params\": lmfit.Parameters or dict, \"aic\": float, \"bic\": float, \"rmse\": float, \"r_squared\": float, \"chi_square\": float, \"reduced_chi_square\": float, }","title":"Stored Data"},{"location":"dev/fit_comparison/#supported-strategies","text":"1D Fit: Overlays different model predictions on a scatter plot of X, Y . Fit per Y (multi-1D): Recomputes predictions for each Y slice, plots curves on X, Z .","title":"Supported Strategies"},{"location":"dev/fit_comparison/#key-methods","text":"Method Description store_current_fit() Saves the current model result to internal list toggle_comparison_mode() Shows/hides the comparison interface create_comparison_ui() Builds dock with plot, list, table, and export button redraw_comparison_plot() Redraws model predictions over data depending on selected fits export_comparison_csv() Saves all stored results to a CSV file reset() Clears all stored data and disables comparison mode","title":"Key Methods"},{"location":"dev/fit_comparison/#dependencies","text":"Requires fit_tab.plot_widget.result to be set. Uses parse_formula() to dynamically recreate fit functions for plotting. Compatible with both lmfit.ModelResult and custom dicts from emcee / odr .","title":"Dependencies"},{"location":"dev/fit_control/","text":"FitControl The FitControl class manages the orchestration of the fitting process for a given dataset. It instantiates and controls the Fit Control dock , handles the execution of the fit across all modes (1D, multi-1D, surface), and communicates with the FitProcessor , MainWindow toolbar, and PlotWidget . Role in the Application Resides inside each FitTab as a dock widget Provides main buttons: Run Fit , Reset Fit , and Manual Manages fit execution for all strategies and methods ( lmfit , odr , emcee ) Delegates core fitting to FitProcessor Updates fit reports, plot visuals, and toolbar state accordingly Interface Overview The FitControl dock contains: Run Fit button Reset Fit button Manual toggle (for opening sliders) Optional strategy combo box when in 2D mode: Fit surface Fit per Y The dock is built dynamically using a vertical layout ( QVBoxLayout ) and is hidden by default. Fit Modes Supported Mode Description 1D Standard curve fit y = f(x) Fit per Y Multi-curve fit z = f(x) at fixed y slices Fit surface Full 2D model fit z = f(x, y) The mode is automatically determined by the data shape ( X,Y vs X,Y,Z ). The strategy is only visible in 2D. Fit Execution Logic Each time Run Fit is clicked, the following occurs: method = fit_options.get(\"method\", \"leastsq\") strategy = self.strategy_selector.currentText() if mode == \"2D\": if strategy == \"Fit per Y\": self._run_fit_per_y(method) else: self._run_fit_surface(method) else: self._run_fit_process(method) Each sub-method handles: formula parsing data extraction call to FitProcessor storing results into PlotWidget updating toolbar and result dock Grouped Methods in FitControl 1. Initialization and UI Method Description __init__() Initializes dock and internal widgets _init_ui() Calls all UI setup sub-methods _create_dock() Builds and inserts the dock _create_buttons() Sets up Run, Reset, Manual buttons _create_strategy_selector() Adds strategy combo box for 2D _assemble_layout() Finalizes layout with all components 2. Fit Dispatchers Method Description run_fit() Top-level dispatcher for all modes _run_fit_process() Runs 1D fit _run_fit_per_y() Runs multi 1D (Fit per Y) _run_fit_surface() Runs 2D surface fit 3. Result Handling and Reporting Method Description _handle_fit_result() Receives result and updates plot, dock, toolbar _generate_fit_report() Calls formatting function depending on method _format_emcee_report() Formats result dict from MCMC _format_odr_report() Formats ODR result into readable string 4. Utility and Sync Method Description reset_fit() Resets plot and toolbar to default state display_fit_results() Makes fit panel visible get_formula_or_warn() Reads formula or shows error dialog _get_selected_or_full_data() Extracts X/Y/Z from selection or all data update_strategy_selector(visible) Shows/hides strategy selector get_current_strategy() Returns selected strategy for 2D fit _on_strategy_change() Updates plots when strategy is changed Related Modules Module Role fit_tab.py Hosts the FitControl dock inside each tab fit_processor.py Implements actual fit logic and dispatch plot_widget.py Receives and displays fits and confidence data toolbar.py Updated by FitControl to reflect fit state fit_formula.py Provides the input formula as text Notes FitControl does not manage formula or data directly \u2014 it pulls them from its parent FitTab All fit result objects are stored in PlotWidget after processing, including residuals and confidence bands The dock remains hidden unless data is loaded","title":"Fit Control"},{"location":"dev/fit_control/#fitcontrol","text":"The FitControl class manages the orchestration of the fitting process for a given dataset. It instantiates and controls the Fit Control dock , handles the execution of the fit across all modes (1D, multi-1D, surface), and communicates with the FitProcessor , MainWindow toolbar, and PlotWidget .","title":"FitControl"},{"location":"dev/fit_control/#role-in-the-application","text":"Resides inside each FitTab as a dock widget Provides main buttons: Run Fit , Reset Fit , and Manual Manages fit execution for all strategies and methods ( lmfit , odr , emcee ) Delegates core fitting to FitProcessor Updates fit reports, plot visuals, and toolbar state accordingly","title":"Role in the Application"},{"location":"dev/fit_control/#interface-overview","text":"The FitControl dock contains: Run Fit button Reset Fit button Manual toggle (for opening sliders) Optional strategy combo box when in 2D mode: Fit surface Fit per Y The dock is built dynamically using a vertical layout ( QVBoxLayout ) and is hidden by default.","title":"Interface Overview"},{"location":"dev/fit_control/#fit-modes-supported","text":"Mode Description 1D Standard curve fit y = f(x) Fit per Y Multi-curve fit z = f(x) at fixed y slices Fit surface Full 2D model fit z = f(x, y) The mode is automatically determined by the data shape ( X,Y vs X,Y,Z ). The strategy is only visible in 2D.","title":"Fit Modes Supported"},{"location":"dev/fit_control/#fit-execution-logic","text":"Each time Run Fit is clicked, the following occurs: method = fit_options.get(\"method\", \"leastsq\") strategy = self.strategy_selector.currentText() if mode == \"2D\": if strategy == \"Fit per Y\": self._run_fit_per_y(method) else: self._run_fit_surface(method) else: self._run_fit_process(method) Each sub-method handles: formula parsing data extraction call to FitProcessor storing results into PlotWidget updating toolbar and result dock","title":"Fit Execution Logic"},{"location":"dev/fit_control/#grouped-methods-in-fitcontrol","text":"","title":"Grouped Methods in FitControl"},{"location":"dev/fit_control/#1-initialization-and-ui","text":"Method Description __init__() Initializes dock and internal widgets _init_ui() Calls all UI setup sub-methods _create_dock() Builds and inserts the dock _create_buttons() Sets up Run, Reset, Manual buttons _create_strategy_selector() Adds strategy combo box for 2D _assemble_layout() Finalizes layout with all components","title":"1. Initialization and UI"},{"location":"dev/fit_control/#2-fit-dispatchers","text":"Method Description run_fit() Top-level dispatcher for all modes _run_fit_process() Runs 1D fit _run_fit_per_y() Runs multi 1D (Fit per Y) _run_fit_surface() Runs 2D surface fit","title":"2. Fit Dispatchers"},{"location":"dev/fit_control/#3-result-handling-and-reporting","text":"Method Description _handle_fit_result() Receives result and updates plot, dock, toolbar _generate_fit_report() Calls formatting function depending on method _format_emcee_report() Formats result dict from MCMC _format_odr_report() Formats ODR result into readable string","title":"3. Result Handling and Reporting"},{"location":"dev/fit_control/#4-utility-and-sync","text":"Method Description reset_fit() Resets plot and toolbar to default state display_fit_results() Makes fit panel visible get_formula_or_warn() Reads formula or shows error dialog _get_selected_or_full_data() Extracts X/Y/Z from selection or all data update_strategy_selector(visible) Shows/hides strategy selector get_current_strategy() Returns selected strategy for 2D fit _on_strategy_change() Updates plots when strategy is changed","title":"4. Utility and Sync"},{"location":"dev/fit_control/#related-modules","text":"Module Role fit_tab.py Hosts the FitControl dock inside each tab fit_processor.py Implements actual fit logic and dispatch plot_widget.py Receives and displays fits and confidence data toolbar.py Updated by FitControl to reflect fit state fit_formula.py Provides the input formula as text","title":"Related Modules"},{"location":"dev/fit_control/#notes","text":"FitControl does not manage formula or data directly \u2014 it pulls them from its parent FitTab All fit result objects are stored in PlotWidget after processing, including residuals and confidence bands The dock remains hidden unless data is loaded","title":"Notes"},{"location":"dev/fit_processor/","text":"FitProcessor The FitProcessor class encapsulates all curve fitting logic, independently of the UI. It handles multiple fitting strategies ( lmfit , ODR , emcee ) and supports 1D fitting, multi-1D (Fit per Y), and full 2D surface fitting. Responsibilities Convert a formula string to a Python function ( generate_fit_function ) Prepare fitting parameters and options ( prepare_parameters ) Dispatch the fitting logic depending on the selected method and strategy Return results in a unified format: (result, minimizer, best_fit, confidence_band) Entry Points 1. Standard 1D Fit result, model, best_fit, band = processor.process_fit( formula=\"y = A * exp(-B * x)\", x_data=x, y_data=y, weights=w, weighting_method=\"None\", ) Dispatches to: lmfit \u2192 _process_lmfit() odr \u2192 _process_odr() emcee \u2192 _run_emcee() 2. Multi 1D Fit (Z = f(X) with fixed Y) result, minimizer, best_fit, band = processor.process_fit_per_y(formula, x, y, z) Performs a global fit with Y treated as a fixed value in each Z slice. Supports lmfit , odr , emcee . 3. Full 2D Surface Fit func = processor.generate_fit_function(formula) result, _, best_fit, band = processor.process_fit_surface(formula, func, x, y, z) Z is modeled as a function of both X and Y. Each method is supported: lmfit : process_fit_surface odr : process_fit_surface_odr emcee : process_fit_surface_emcee MCMC Support (emcee) All MCMC fits are handled via: _run_emcee(func, param_info, inputs, targets, sigma, fit_options, mode) The mode argument changes the likelihood evaluation: \"1d\" \"per_y\" (multi 1D) \"surface\" Returns: result: dict sampler: emcee.EnsembleSampler best_fit: np.ndarray confidence_band: Tuple[np.ndarray, np.ndarray] Confidence Bands The 99% confidence bands are: computed from result.eval_uncertainty(sigma=3) in lmfit extracted from the MCMC prediction percentiles approximated via the covariance matrix in ODR Method Summary Method Role generate_fit_function() Turns formula into executable Python function prepare_parameters() Extracts p0, bounds from FitOptions dialog process_fit() Entry for standard 1D fit process_fit_per_y() Entry for multi-1D fit (Z = f(X), fixed Y) process_fit_surface() Entry for full surface fit _run_emcee() Shared backend for MCMC fits _process_lmfit() Core least-squares fitting with lmfit.Model _process_odr() Fitting using orthogonal distance regression (ODR) reset_fit() Clears result, toolbar, and reinitializes plots","title":"Fit Processor"},{"location":"dev/fit_processor/#fitprocessor","text":"The FitProcessor class encapsulates all curve fitting logic, independently of the UI. It handles multiple fitting strategies ( lmfit , ODR , emcee ) and supports 1D fitting, multi-1D (Fit per Y), and full 2D surface fitting.","title":"FitProcessor"},{"location":"dev/fit_processor/#responsibilities","text":"Convert a formula string to a Python function ( generate_fit_function ) Prepare fitting parameters and options ( prepare_parameters ) Dispatch the fitting logic depending on the selected method and strategy Return results in a unified format: (result, minimizer, best_fit, confidence_band)","title":"Responsibilities"},{"location":"dev/fit_processor/#entry-points","text":"","title":"Entry Points"},{"location":"dev/fit_processor/#1-standard-1d-fit","text":"result, model, best_fit, band = processor.process_fit( formula=\"y = A * exp(-B * x)\", x_data=x, y_data=y, weights=w, weighting_method=\"None\", ) Dispatches to: lmfit \u2192 _process_lmfit() odr \u2192 _process_odr() emcee \u2192 _run_emcee()","title":"1. Standard 1D Fit"},{"location":"dev/fit_processor/#2-multi-1d-fit-z-fx-with-fixed-y","text":"result, minimizer, best_fit, band = processor.process_fit_per_y(formula, x, y, z) Performs a global fit with Y treated as a fixed value in each Z slice. Supports lmfit , odr , emcee .","title":"2. Multi 1D Fit (Z = f(X) with fixed Y)"},{"location":"dev/fit_processor/#3-full-2d-surface-fit","text":"func = processor.generate_fit_function(formula) result, _, best_fit, band = processor.process_fit_surface(formula, func, x, y, z) Z is modeled as a function of both X and Y. Each method is supported: lmfit : process_fit_surface odr : process_fit_surface_odr emcee : process_fit_surface_emcee","title":"3. Full 2D Surface Fit"},{"location":"dev/fit_processor/#mcmc-support-emcee","text":"All MCMC fits are handled via: _run_emcee(func, param_info, inputs, targets, sigma, fit_options, mode) The mode argument changes the likelihood evaluation: \"1d\" \"per_y\" (multi 1D) \"surface\" Returns: result: dict sampler: emcee.EnsembleSampler best_fit: np.ndarray confidence_band: Tuple[np.ndarray, np.ndarray]","title":"MCMC Support (emcee)"},{"location":"dev/fit_processor/#confidence-bands","text":"The 99% confidence bands are: computed from result.eval_uncertainty(sigma=3) in lmfit extracted from the MCMC prediction percentiles approximated via the covariance matrix in ODR","title":"Confidence Bands"},{"location":"dev/fit_processor/#method-summary","text":"Method Role generate_fit_function() Turns formula into executable Python function prepare_parameters() Extracts p0, bounds from FitOptions dialog process_fit() Entry for standard 1D fit process_fit_per_y() Entry for multi-1D fit (Z = f(X), fixed Y) process_fit_surface() Entry for full surface fit _run_emcee() Shared backend for MCMC fits _process_lmfit() Core least-squares fitting with lmfit.Model _process_odr() Fitting using orthogonal distance regression (ODR) reset_fit() Clears result, toolbar, and reinitializes plots","title":"Method Summary"},{"location":"dev/fit_tab/","text":"FitTab This page documents the FitTab class, which represents the main workspace for fitting a single dataset. It integrates all relevant dock widgets (formula, data, results, fit control) and connects user interactions with core fitting components such as FitControl , PlotWidget , and FitFormulaManager . Role in the Application Represents one dataset and one fitting session Hosts the plot, data display, formula editor, and fit options Manages layout and visibility of all dockable panels Provides access to smoothing and weighting tools Delegates fit execution to FitControl , and rendering to PlotWidget Structure Diagram graph TD FitTab[FitTab] DF[DataFrame] Plot[PlotWidget] FormulaText[QTextEdit: Formula] FormulaManager[FitFormulaManager] FitControl[FitControl] FitOptions[FitOptionsWindow] Manual[ManualControl] ResultsText[QTextEdit: Results] Compare[FitComparisonManager] Docks[Docks: Formula, Plot, Results, XY] Sub[\" \"] FitTab --> DF FitTab --> Plot FitTab --> FormulaText FitTab --> FormulaManager FitTab --> FitControl FitTab --> FitOptions FitTab --> Sub Sub --> Manual Sub --> ResultsText Sub --> Compare Sub --> Docks Responsibilities Stores and validates the current dataset ( self.df ) Detects and adapts to 1D or 2D data modes Provides the dock layout for formula, results, and data views Applies smoothing and weighting methods to raw data Coordinates formula input, fit options, and comparison manager Triggers plot updates (but does not directly execute fits) Attributes Attribute Type Description df pd.DataFrame Loaded data for this tab plot_widget PlotWidget Shared widget for plotting formula_text QTextEdit Formula editor formula_manager FitFormulaManager Parses and manages formula state fit_control FitControl Dock for selecting and launching fit fit_options_dialog FitOptionsWindow Modal dialog to define fit parameters manual_control ManualControl Optional dock for manual parameter input comparison_manager FitComparisonManager Manager for multi-model comparison results_text QTextEdit Area displaying textual fit report dock_formula BaseDockWidget Dock containing formula editor and buttons dock_plot BaseDockWidget Dock containing the main plot dock_results BaseDockWidget Dock showing the fit report dock_xy BaseDockWidget Dock showing raw X/Y/Z data in a table Grouped Methods in FitTab 1. Initialization and Setup Method Role __init__() Constructs widgets, docks, and assigns IDs initUI() Calls individual dock initializers init_plot_dock() Adds main plot area init_formula_dock() Creates formula editor and buttons init_results_dock() Prepares the results panel init_xy_dock() Builds the table for data display 2. Data Loading and Validation Method Role load_data_into_tab(df, path) Injects new data, configures mode (1D/2D) _load_1d_data(df) Prepares table and plot for X/Y data _load_2d_data(df) Prepares table and plot for X/Y/Z data clear_data() Removes data and resets UI _cleanup_manual_control() Removes manual dock when switching datasets 3. Fit and Formula Management Method Role update_fit_options_params() Updates param table in Fit Options dialog open_fit_options() Opens the Fit Options modal and stores selections show_fit_results() Makes fit panel and result label visible update_results_text(report) Sets text of the result dock 4. Smoothing and Weighting Method Role smooth_data(method) Applies smoothing to Y data and replots weight_data(method) Applies error weighting before fit 5. Miscellaneous Method Role create_xy_table() Creates raw table widget for XY(Z) data get_fit_name() Returns label like \"Fit 1\" , \"Fit 2\" show_error_message() Displays a blocking error message popup Notes on Execution Flow Although FitTab does not contain a run_fit() method, it integrates all components required for launching a fit via the FitControl dock. The actual fit is delegated to FitProcessor from within the dock logic. Related Modules Module Role fit_processor.py Executes actual fit calls (lmfit, etc.) plot_widget.py Backend for visualizing data + fit fit_formula.py Parses formula and extracts parameters fit_control.py UI and logic for fit strategy and trigger fit_comparison.py Manages comparison across fits","title":"FitTab"},{"location":"dev/fit_tab/#fittab","text":"This page documents the FitTab class, which represents the main workspace for fitting a single dataset. It integrates all relevant dock widgets (formula, data, results, fit control) and connects user interactions with core fitting components such as FitControl , PlotWidget , and FitFormulaManager .","title":"FitTab"},{"location":"dev/fit_tab/#role-in-the-application","text":"Represents one dataset and one fitting session Hosts the plot, data display, formula editor, and fit options Manages layout and visibility of all dockable panels Provides access to smoothing and weighting tools Delegates fit execution to FitControl , and rendering to PlotWidget","title":"Role in the Application"},{"location":"dev/fit_tab/#structure-diagram","text":"graph TD FitTab[FitTab] DF[DataFrame] Plot[PlotWidget] FormulaText[QTextEdit: Formula] FormulaManager[FitFormulaManager] FitControl[FitControl] FitOptions[FitOptionsWindow] Manual[ManualControl] ResultsText[QTextEdit: Results] Compare[FitComparisonManager] Docks[Docks: Formula, Plot, Results, XY] Sub[\" \"] FitTab --> DF FitTab --> Plot FitTab --> FormulaText FitTab --> FormulaManager FitTab --> FitControl FitTab --> FitOptions FitTab --> Sub Sub --> Manual Sub --> ResultsText Sub --> Compare Sub --> Docks","title":"Structure Diagram"},{"location":"dev/fit_tab/#responsibilities","text":"Stores and validates the current dataset ( self.df ) Detects and adapts to 1D or 2D data modes Provides the dock layout for formula, results, and data views Applies smoothing and weighting methods to raw data Coordinates formula input, fit options, and comparison manager Triggers plot updates (but does not directly execute fits)","title":"Responsibilities"},{"location":"dev/fit_tab/#attributes","text":"Attribute Type Description df pd.DataFrame Loaded data for this tab plot_widget PlotWidget Shared widget for plotting formula_text QTextEdit Formula editor formula_manager FitFormulaManager Parses and manages formula state fit_control FitControl Dock for selecting and launching fit fit_options_dialog FitOptionsWindow Modal dialog to define fit parameters manual_control ManualControl Optional dock for manual parameter input comparison_manager FitComparisonManager Manager for multi-model comparison results_text QTextEdit Area displaying textual fit report dock_formula BaseDockWidget Dock containing formula editor and buttons dock_plot BaseDockWidget Dock containing the main plot dock_results BaseDockWidget Dock showing the fit report dock_xy BaseDockWidget Dock showing raw X/Y/Z data in a table","title":"Attributes"},{"location":"dev/fit_tab/#grouped-methods-in-fittab","text":"","title":"Grouped Methods in FitTab"},{"location":"dev/fit_tab/#1-initialization-and-setup","text":"Method Role __init__() Constructs widgets, docks, and assigns IDs initUI() Calls individual dock initializers init_plot_dock() Adds main plot area init_formula_dock() Creates formula editor and buttons init_results_dock() Prepares the results panel init_xy_dock() Builds the table for data display","title":"1. Initialization and Setup"},{"location":"dev/fit_tab/#2-data-loading-and-validation","text":"Method Role load_data_into_tab(df, path) Injects new data, configures mode (1D/2D) _load_1d_data(df) Prepares table and plot for X/Y data _load_2d_data(df) Prepares table and plot for X/Y/Z data clear_data() Removes data and resets UI _cleanup_manual_control() Removes manual dock when switching datasets","title":"2. Data Loading and Validation"},{"location":"dev/fit_tab/#3-fit-and-formula-management","text":"Method Role update_fit_options_params() Updates param table in Fit Options dialog open_fit_options() Opens the Fit Options modal and stores selections show_fit_results() Makes fit panel and result label visible update_results_text(report) Sets text of the result dock","title":"3. Fit and Formula Management"},{"location":"dev/fit_tab/#4-smoothing-and-weighting","text":"Method Role smooth_data(method) Applies smoothing to Y data and replots weight_data(method) Applies error weighting before fit","title":"4. Smoothing and Weighting"},{"location":"dev/fit_tab/#5-miscellaneous","text":"Method Role create_xy_table() Creates raw table widget for XY(Z) data get_fit_name() Returns label like \"Fit 1\" , \"Fit 2\" show_error_message() Displays a blocking error message popup","title":"5. Miscellaneous"},{"location":"dev/fit_tab/#notes-on-execution-flow","text":"Although FitTab does not contain a run_fit() method, it integrates all components required for launching a fit via the FitControl dock. The actual fit is delegated to FitProcessor from within the dock logic.","title":"Notes on Execution Flow"},{"location":"dev/fit_tab/#related-modules","text":"Module Role fit_processor.py Executes actual fit calls (lmfit, etc.) plot_widget.py Backend for visualizing data + fit fit_formula.py Parses formula and extracts parameters fit_control.py UI and logic for fit strategy and trigger fit_comparison.py Manages comparison across fits","title":"Related Modules"},{"location":"dev/overview/","text":"Application Entry and Main Window This document describes the responsibilities and structure of the MainWindow class, which serves as the central controller of the user interface. It manages tabs, toolbars, menus, layout state, and forwards loaded data to the active tab. While it plays a crucial structural role, it delegates all domain-specific logic (e.g. fitting, plotting) to components like FitTab . The class is currently very large and tightly coupled. It would benefit from a future refactoring to isolate responsibilities more clearly. Role of MainWindow Hosts all top-level UI components (toolbar, menus, tabs) Creates and switches between tabs ( FitTab , etc.) Manages global application layout and dock visibility Handles file I/O operations through menu actions Injects loaded data into the current tab System Diagram graph TD Main[MainWindow] Fit[FitTab] Plot[PlotWidget] Toolbar[Toolbar] Config[ConfigManager] Loader[DataLoader] MenuBar[Menu Bar] Docks[Dock Widgets] Main --> Fit Main --> Toolbar Main --> MenuBar Main --> Config Main --> Loader Fit --> Plot Fit --> Docks UI Initialization class MainWindow(QMainWindow): def __init__(self): self.config = ConfigManager() self.setFixedSize(...) self._init_interface() All core components (menu bar, toolbar, tab container, status bar) are initialized once in _init_interface() . A first FitTab is created by default. Tab Lifecycle Tabs are created using add_fit_tab() and inserted into the central QTabWidget . When the user switches tabs, the View menu is rebuilt to reflect the correct dock widgets and toolbar state. plot_widget = PlotWidget(self) new_tab = FitTab(self, plot_widget) self.tabs.addTab(new_tab, new_tab.get_fit_name()) Dock Visibility and View Menu Each tab manages its own docks (fit panel, plot, results...). The MainWindow maintains a mapping of visible docks and their associated menu actions for each tab: self.view_actions_per_tab[tab] = { \"Fit Formula\": (action, dock), ... } When switching tabs, the view menu is cleared and rebuilt accordingly. Grouped Methods in MainWindow The table below categorizes each method by role. 1. Initialization Method Role __init__() Reads config and initializes main UI layout _init_interface() Builds toolbar, menus, status bar, tab system 2. Menu Setup Method Role _init_file_menu() Creates File menu: Load, Export, Exit _init_fits_menu() Adds New/Close Fit actions _init_view_menu() Connects menu items to dock visibility 3. Tab Management Method Role add_fit_tab() Creates a new FitTab and activates it get_current_fit_tab() Returns active FitTab or None close_fit_tab(index) Closes tab at the given index rename_tab(index) Renames tab via inline QLineEdit duplicate_tab(index) Copies data, formula, and options to new tab 4. View State & Docks Method Role _update_view_menu_for_current_tab() Rebuilds View menu when tab changes _init_view_menu() Registers visibility toggles for tab docks restore_default_view() Restores all docks in current tab _snapshot_dock_states_before_switch(index) Saves dock state before tab switch 5. Toolbar State Method Role enable_toolbar_buttons(enabled) Enables/disables toolbar buttons after a fit _snapshot_toolbar_state(tab) Records which toolbar buttons are enabled _restore_toolbar_state(tab) Re-applies the saved toolbar state 6. Data I/O Method Role load_data_from_menu() Loads data via file dialog load_previous_data() Loads last accessed file _inject_data_into_tab() Injects DataFrame into current tab unload_data() Clears data from the current tab export_data() Exports current data to CSV 7. Status Method Role show_status() Displays message in the status bar 8. App Entry Point Method Role main() Entry point to launch the app Connected Modules Component Description FitTab Main per-dataset fit interface Toolbar Global toolbar shared across tabs PlotWidget Rendering backend used by each tab ConfigManager Manages saved layout, window size DataLoader Handles file selection and parsing Notes This class is currently responsible for too many aspects of the interface: tab lifecycle, dock logic, toolbar state, file handling, and persistence. Future work could separate: Tab creation logic Menu construction Toolbar state tracking Layout state into a controller class","title":"Overview"},{"location":"dev/overview/#application-entry-and-main-window","text":"This document describes the responsibilities and structure of the MainWindow class, which serves as the central controller of the user interface. It manages tabs, toolbars, menus, layout state, and forwards loaded data to the active tab. While it plays a crucial structural role, it delegates all domain-specific logic (e.g. fitting, plotting) to components like FitTab . The class is currently very large and tightly coupled. It would benefit from a future refactoring to isolate responsibilities more clearly.","title":"Application Entry and Main Window"},{"location":"dev/overview/#role-of-mainwindow","text":"Hosts all top-level UI components (toolbar, menus, tabs) Creates and switches between tabs ( FitTab , etc.) Manages global application layout and dock visibility Handles file I/O operations through menu actions Injects loaded data into the current tab","title":"Role of MainWindow"},{"location":"dev/overview/#system-diagram","text":"graph TD Main[MainWindow] Fit[FitTab] Plot[PlotWidget] Toolbar[Toolbar] Config[ConfigManager] Loader[DataLoader] MenuBar[Menu Bar] Docks[Dock Widgets] Main --> Fit Main --> Toolbar Main --> MenuBar Main --> Config Main --> Loader Fit --> Plot Fit --> Docks","title":"System Diagram"},{"location":"dev/overview/#ui-initialization","text":"class MainWindow(QMainWindow): def __init__(self): self.config = ConfigManager() self.setFixedSize(...) self._init_interface() All core components (menu bar, toolbar, tab container, status bar) are initialized once in _init_interface() . A first FitTab is created by default.","title":"UI Initialization"},{"location":"dev/overview/#tab-lifecycle","text":"Tabs are created using add_fit_tab() and inserted into the central QTabWidget . When the user switches tabs, the View menu is rebuilt to reflect the correct dock widgets and toolbar state. plot_widget = PlotWidget(self) new_tab = FitTab(self, plot_widget) self.tabs.addTab(new_tab, new_tab.get_fit_name())","title":"Tab Lifecycle"},{"location":"dev/overview/#dock-visibility-and-view-menu","text":"Each tab manages its own docks (fit panel, plot, results...). The MainWindow maintains a mapping of visible docks and their associated menu actions for each tab: self.view_actions_per_tab[tab] = { \"Fit Formula\": (action, dock), ... } When switching tabs, the view menu is cleared and rebuilt accordingly.","title":"Dock Visibility and View Menu"},{"location":"dev/overview/#grouped-methods-in-mainwindow","text":"The table below categorizes each method by role.","title":"Grouped Methods in MainWindow"},{"location":"dev/overview/#1-initialization","text":"Method Role __init__() Reads config and initializes main UI layout _init_interface() Builds toolbar, menus, status bar, tab system","title":"1. Initialization"},{"location":"dev/overview/#2-menu-setup","text":"Method Role _init_file_menu() Creates File menu: Load, Export, Exit _init_fits_menu() Adds New/Close Fit actions _init_view_menu() Connects menu items to dock visibility","title":"2. Menu Setup"},{"location":"dev/overview/#3-tab-management","text":"Method Role add_fit_tab() Creates a new FitTab and activates it get_current_fit_tab() Returns active FitTab or None close_fit_tab(index) Closes tab at the given index rename_tab(index) Renames tab via inline QLineEdit duplicate_tab(index) Copies data, formula, and options to new tab","title":"3. Tab Management"},{"location":"dev/overview/#4-view-state-docks","text":"Method Role _update_view_menu_for_current_tab() Rebuilds View menu when tab changes _init_view_menu() Registers visibility toggles for tab docks restore_default_view() Restores all docks in current tab _snapshot_dock_states_before_switch(index) Saves dock state before tab switch","title":"4. View State &amp; Docks"},{"location":"dev/overview/#5-toolbar-state","text":"Method Role enable_toolbar_buttons(enabled) Enables/disables toolbar buttons after a fit _snapshot_toolbar_state(tab) Records which toolbar buttons are enabled _restore_toolbar_state(tab) Re-applies the saved toolbar state","title":"5. Toolbar State"},{"location":"dev/overview/#6-data-io","text":"Method Role load_data_from_menu() Loads data via file dialog load_previous_data() Loads last accessed file _inject_data_into_tab() Injects DataFrame into current tab unload_data() Clears data from the current tab export_data() Exports current data to CSV","title":"6. Data I/O"},{"location":"dev/overview/#7-status","text":"Method Role show_status() Displays message in the status bar","title":"7. Status"},{"location":"dev/overview/#8-app-entry-point","text":"Method Role main() Entry point to launch the app","title":"8. App Entry Point"},{"location":"dev/overview/#connected-modules","text":"Component Description FitTab Main per-dataset fit interface Toolbar Global toolbar shared across tabs PlotWidget Rendering backend used by each tab ConfigManager Manages saved layout, window size DataLoader Handles file selection and parsing","title":"Connected Modules"},{"location":"dev/overview/#notes","text":"This class is currently responsible for too many aspects of the interface: tab lifecycle, dock logic, toolbar state, file handling, and persistence. Future work could separate: Tab creation logic Menu construction Toolbar state tracking Layout state into a controller class","title":"Notes"},{"location":"dev/plot/","text":"Plot System Overview This page summarizes all plotting components used in the application. It includes 1D fits, multi-1D fits, 2D surface fits, confidence bands, residuals, MCMC diagnostics, and model comparison. Global Plot Architecture graph TD MainWindow --> FitTab FitTab --> PlotWidget FitTab --> FitProcessor FitTab --> FitComparisonManager FitProcessor -->|fit result| PlotWidget FitComparisonManager -->|draw| PlotWidget PlotWidget -->|1D / Residuals| plot.py PlotWidget -->|2D: scatter/surface| plot2d.py PlotWidget -->|MCMC| mcmc_plot.py 1. 1D Fit Plots ( plot.py ) These are methods or utilities used for plotting raw 1D data, fitted curves, residuals, and confidence intervals. Function / Method Description Location PlotWidget.plot_data(df) Plots raw 1D data (X, Y) plot.py PlotWidget.plot_fit(x, y) Plots fitted curve on top of data plot.py PlotAnalysis.toggle_residuals_plot() Toggles residuals plot (Y - fit) plot_analysis.py PlotAnalysis.toggle_confidence_band() Toggles display of confidence intervals plot_analysis.py 2. Multi-1D Fit (Fit per Y) ( plot2d.py ) Plots used when performing a fit Z = f(X, Y_fixed) for multiple Y values. Function Description Location plot_multi1d_data(ax, canvas, x, y, z, pw) Plots raw grouped data plot2d.py plot_multi1d_fit(ax, canvas, fits, pw) Overlays fitted curves Z=f(X,Y_fixed) plot2d.py PlotAnalysis.toggle_confidence_band() Confidence bands over Y slices plot_analysis.py PlotAnalysis.toggle_residuals_plot() (mode: multi 1D) Residual plots per Y plot_analysis.py 3. 2D Surface Fit ( plot2d.py ) Used for true 2D fits where Z = f(X, Y), showing surface and contour. Function Description Location plot_2d_series(x, y, z, strategy) Raw Z data as scatter grouped by strategy plot2d.py plot_2d_surface_fit(ax, canvas, x, y, z, fit, pw) Fitted surface + 3D view + contour plot2d.py PlotAnalysis.plot_conf_interval_2d() Confidence region for surface fit plot_analysis.py 4. MCMC Diagnostic Plots ( mcmc_plot.py ) Generated after a successful fit with emcee . Function / Method Description Location MCMCPlot.show_mcmc_results(...) Dispatches the diagnostic plots mcmc_plot.py MCMCPlot.plot_walkers(...) Shows evolution of walker chains per param mcmc_plot.py MCMCPlot.plot_corner(...) Displays parameter correlations (corner) mcmc_plot.py MCMCPlot.plot_autocorrelation(...) Autocorrelation of each parameter chain mcmc_plot.py --- 5. Comparison Plot ( fit_comparison.py ) Plots used in comparison mode to overlay stored fits. Function / Method Description Location FitComparisonManager.redraw_comparison_plot() Rebuilds the fit overlay plot fit_comparison.py FitComparisonManager.create_comparison_plot() Initializes the matplotlib canvas fit_comparison.py 6. Manual Fit Mode In manual mode (sliders), the same plot functions are reused. Function / Method Description Location PlotWidget.plot_data(df) Raw data (X, Y) plot.py PlotWidget.plot_fit(x, y) Manual fit preview from sliders plot.py","title":"Plot System"},{"location":"dev/plot/#plot-system-overview","text":"This page summarizes all plotting components used in the application. It includes 1D fits, multi-1D fits, 2D surface fits, confidence bands, residuals, MCMC diagnostics, and model comparison.","title":"Plot System Overview"},{"location":"dev/plot/#global-plot-architecture","text":"graph TD MainWindow --> FitTab FitTab --> PlotWidget FitTab --> FitProcessor FitTab --> FitComparisonManager FitProcessor -->|fit result| PlotWidget FitComparisonManager -->|draw| PlotWidget PlotWidget -->|1D / Residuals| plot.py PlotWidget -->|2D: scatter/surface| plot2d.py PlotWidget -->|MCMC| mcmc_plot.py","title":"Global Plot Architecture"},{"location":"dev/plot/#1-1d-fit-plots-plotpy","text":"These are methods or utilities used for plotting raw 1D data, fitted curves, residuals, and confidence intervals. Function / Method Description Location PlotWidget.plot_data(df) Plots raw 1D data (X, Y) plot.py PlotWidget.plot_fit(x, y) Plots fitted curve on top of data plot.py PlotAnalysis.toggle_residuals_plot() Toggles residuals plot (Y - fit) plot_analysis.py PlotAnalysis.toggle_confidence_band() Toggles display of confidence intervals plot_analysis.py","title":"1. 1D Fit Plots (plot.py)"},{"location":"dev/plot/#2-multi-1d-fit-fit-per-y-plot2dpy","text":"Plots used when performing a fit Z = f(X, Y_fixed) for multiple Y values. Function Description Location plot_multi1d_data(ax, canvas, x, y, z, pw) Plots raw grouped data plot2d.py plot_multi1d_fit(ax, canvas, fits, pw) Overlays fitted curves Z=f(X,Y_fixed) plot2d.py PlotAnalysis.toggle_confidence_band() Confidence bands over Y slices plot_analysis.py PlotAnalysis.toggle_residuals_plot() (mode: multi 1D) Residual plots per Y plot_analysis.py","title":"2. Multi-1D Fit (Fit per Y) (plot2d.py)"},{"location":"dev/plot/#3-2d-surface-fit-plot2dpy","text":"Used for true 2D fits where Z = f(X, Y), showing surface and contour. Function Description Location plot_2d_series(x, y, z, strategy) Raw Z data as scatter grouped by strategy plot2d.py plot_2d_surface_fit(ax, canvas, x, y, z, fit, pw) Fitted surface + 3D view + contour plot2d.py PlotAnalysis.plot_conf_interval_2d() Confidence region for surface fit plot_analysis.py","title":"3. 2D Surface Fit (plot2d.py)"},{"location":"dev/plot/#4-mcmc-diagnostic-plots-mcmc_plotpy","text":"Generated after a successful fit with emcee . Function / Method Description Location MCMCPlot.show_mcmc_results(...) Dispatches the diagnostic plots mcmc_plot.py MCMCPlot.plot_walkers(...) Shows evolution of walker chains per param mcmc_plot.py MCMCPlot.plot_corner(...) Displays parameter correlations (corner) mcmc_plot.py MCMCPlot.plot_autocorrelation(...) Autocorrelation of each parameter chain mcmc_plot.py ---","title":"4. MCMC Diagnostic Plots (mcmc_plot.py)"},{"location":"dev/plot/#5-comparison-plot-fit_comparisonpy","text":"Plots used in comparison mode to overlay stored fits. Function / Method Description Location FitComparisonManager.redraw_comparison_plot() Rebuilds the fit overlay plot fit_comparison.py FitComparisonManager.create_comparison_plot() Initializes the matplotlib canvas fit_comparison.py","title":"5. Comparison Plot (fit_comparison.py)"},{"location":"dev/plot/#6-manual-fit-mode","text":"In manual mode (sliders), the same plot functions are reused. Function / Method Description Location PlotWidget.plot_data(df) Raw data (X, Y) plot.py PlotWidget.plot_fit(x, y) Manual fit preview from sliders plot.py","title":"6. Manual Fit Mode"},{"location":"dev/toolbar/","text":"Toolbar This page documents the Toolbar class, which defines and manages all global user actions accessible via the top toolbar. These include launching a fit, toggling visual layers (residuals, confidence bands), and selecting fitting options such as method, smoothing, or weighting. The toolbar is created once by MainWindow , and emits Qt signals when the user interacts with it. Structure Diagram graph TD MainWindow --> Toolbar Toolbar --> QActionResiduals[Residuals] Toolbar --> QActionConfidence[Confidence] Toolbar --> Smoothing Toolbar --> Weighting Toolbar --> a[X selection] Toolbar --> Compararison Responsibilities Provides buttons for toggling residuals, confidence bands, components Includes menus for smoothing and weighting options Connects to FitTab and PlotWidget to trigger visual updates Adds or compares fit results across multiple runs Actions and Menus Action/Menu Type Icon Description toggle_confidence QAction conf_1d.png Show 99% confidence band (1D fit) toggle_residuals QAction resi.png Show residuals (data - fit) toggle_components QAction decomp.png Show component contributions toggle_conf_2d QAction conf_2d.png Show 2D confidence region (e.g. ellipse) set_xmin_xmax Checkable text only Select X-range for fit smoothing_menu QMenu Gaussian, Moving Average, None weighting_menu QMenu x_err, y_err, xy_err, none add_fit QAction none Add current fit to comparison list toggle_comparison Checkable none Enable comparison mode Signal Flow All logic is internal to the toolbar and calls back into FitTab or PlotWidget . self.toggle_residuals_action.triggered.connect(self.toggle_residuals) self.smooth_gaussian_action.triggered.connect(lambda: self._apply_smoothing(\"savgol\")) Integration with FitTab Called Method Purpose tab.plot_widget.analysis_plot.toggle_residuals_plot() toggle residual display tab.weight_data(\"x_err\") apply weighting method tab.smooth_data(\"avg\") apply smoothing method tab.comparison_manager.store_current_fit() save current result Related Files toolbar.py : UI structure and action handling toolbar_actions.py : (optional) separate logic if extracted main_window.py : connects toolbar to current tab plot_analysis.py : defines the toggleable plot elements","title":"Toolbar"},{"location":"dev/toolbar/#toolbar","text":"This page documents the Toolbar class, which defines and manages all global user actions accessible via the top toolbar. These include launching a fit, toggling visual layers (residuals, confidence bands), and selecting fitting options such as method, smoothing, or weighting. The toolbar is created once by MainWindow , and emits Qt signals when the user interacts with it.","title":"Toolbar"},{"location":"dev/toolbar/#structure-diagram","text":"graph TD MainWindow --> Toolbar Toolbar --> QActionResiduals[Residuals] Toolbar --> QActionConfidence[Confidence] Toolbar --> Smoothing Toolbar --> Weighting Toolbar --> a[X selection] Toolbar --> Compararison","title":"Structure Diagram"},{"location":"dev/toolbar/#responsibilities","text":"Provides buttons for toggling residuals, confidence bands, components Includes menus for smoothing and weighting options Connects to FitTab and PlotWidget to trigger visual updates Adds or compares fit results across multiple runs","title":"Responsibilities"},{"location":"dev/toolbar/#actions-and-menus","text":"Action/Menu Type Icon Description toggle_confidence QAction conf_1d.png Show 99% confidence band (1D fit) toggle_residuals QAction resi.png Show residuals (data - fit) toggle_components QAction decomp.png Show component contributions toggle_conf_2d QAction conf_2d.png Show 2D confidence region (e.g. ellipse) set_xmin_xmax Checkable text only Select X-range for fit smoothing_menu QMenu Gaussian, Moving Average, None weighting_menu QMenu x_err, y_err, xy_err, none add_fit QAction none Add current fit to comparison list toggle_comparison Checkable none Enable comparison mode","title":"Actions and Menus"},{"location":"dev/toolbar/#signal-flow","text":"All logic is internal to the toolbar and calls back into FitTab or PlotWidget . self.toggle_residuals_action.triggered.connect(self.toggle_residuals) self.smooth_gaussian_action.triggered.connect(lambda: self._apply_smoothing(\"savgol\"))","title":"Signal Flow"},{"location":"dev/toolbar/#integration-with-fittab","text":"Called Method Purpose tab.plot_widget.analysis_plot.toggle_residuals_plot() toggle residual display tab.weight_data(\"x_err\") apply weighting method tab.smooth_data(\"avg\") apply smoothing method tab.comparison_manager.store_current_fit() save current result","title":"Integration with FitTab"},{"location":"dev/toolbar/#related-files","text":"toolbar.py : UI structure and action handling toolbar_actions.py : (optional) separate logic if extracted main_window.py : connects toolbar to current tab plot_analysis.py : defines the toggleable plot elements","title":"Related Files"},{"location":"fit/fit_comparison/","text":"Fit Comparison The Fit Comparison mode allows users to store and visualize multiple fitting results side-by-side for the same dataset (1D). This is particularly useful for testing different models, weighting strategies, or fitting methods (e.g., lmfit , odr , or emcee ) and evaluating which configuration provides the most accurate or meaningful result. Overview Once enabled, comparison mode overlays stored fits onto the main plot as additional curves. Each stored result is displayed in a distinct dashed line and accompanied by a summary table showing key fitting metrics. The raw data remains visible, ensuring that all models can be evaluated relative to the same experimental points. Key Features Overlay multiple stored fits on a single dataset. Each fit is rendered with a unique dashed color for clarity. Interactive checkbox panel below the plot to toggle fit visibility. Summary table with metrics for each stored fit (formula, method, AIC, BIC, RMSE, etc.). Export summary tabel in .csv file. Voici une section suppl\u00e9mentaire que tu peux ajouter \u00e0 la fin de la documentation fit_comparison.md , pour d\u00e9crire la fonction Export Comparison CSV , avec un exemple concret bas\u00e9 sur ton image : Exporting the Comparison Table Once multiple fits have been added and comparison mode is active, the Export Comparison CSV button allows you to save the full summary table as a .csv file. This file includes: Fit name and formula Method used ( leastsq , emcee , etc.) Source data path Estimated parameter values (with uncertainties) Fit statistics: AIC, BIC, RMSE, \u03c7\u00b2, R\u00b2 Usage Run a fit as usual (using any supported method). Click the Add Fit button in the toolbar to store the result. Enable Comparison Mode by toggling the Compare button in the toolbar. All stored fits will be displayed in the main plot with their details below. Use checkboxes to show/hide individual curves or remove fits from the comparison list. Behavior The stored fits are specific to the active tab and not shared across sessions or datasets. Fits remain available as long as the tab is open and the data is unchanged. If the dataset is cleared or reloaded, the comparison list is reset. Limitations Manual fits cannot be stored or compared. Fits are not saved between sessions. Only the best-fit curve is stored, not confidence intervals or MCMC traces.","title":"Comparison"},{"location":"fit/fit_comparison/#fit-comparison","text":"The Fit Comparison mode allows users to store and visualize multiple fitting results side-by-side for the same dataset (1D). This is particularly useful for testing different models, weighting strategies, or fitting methods (e.g., lmfit , odr , or emcee ) and evaluating which configuration provides the most accurate or meaningful result.","title":"Fit Comparison"},{"location":"fit/fit_comparison/#overview","text":"Once enabled, comparison mode overlays stored fits onto the main plot as additional curves. Each stored result is displayed in a distinct dashed line and accompanied by a summary table showing key fitting metrics. The raw data remains visible, ensuring that all models can be evaluated relative to the same experimental points.","title":"Overview"},{"location":"fit/fit_comparison/#key-features","text":"Overlay multiple stored fits on a single dataset. Each fit is rendered with a unique dashed color for clarity. Interactive checkbox panel below the plot to toggle fit visibility. Summary table with metrics for each stored fit (formula, method, AIC, BIC, RMSE, etc.). Export summary tabel in .csv file. Voici une section suppl\u00e9mentaire que tu peux ajouter \u00e0 la fin de la documentation fit_comparison.md , pour d\u00e9crire la fonction Export Comparison CSV , avec un exemple concret bas\u00e9 sur ton image :","title":"Key Features"},{"location":"fit/fit_comparison/#exporting-the-comparison-table","text":"Once multiple fits have been added and comparison mode is active, the Export Comparison CSV button allows you to save the full summary table as a .csv file. This file includes: Fit name and formula Method used ( leastsq , emcee , etc.) Source data path Estimated parameter values (with uncertainties) Fit statistics: AIC, BIC, RMSE, \u03c7\u00b2, R\u00b2","title":"Exporting the Comparison Table"},{"location":"fit/fit_comparison/#usage","text":"Run a fit as usual (using any supported method). Click the Add Fit button in the toolbar to store the result. Enable Comparison Mode by toggling the Compare button in the toolbar. All stored fits will be displayed in the main plot with their details below. Use checkboxes to show/hide individual curves or remove fits from the comparison list.","title":"Usage"},{"location":"fit/fit_comparison/#behavior","text":"The stored fits are specific to the active tab and not shared across sessions or datasets. Fits remain available as long as the tab is open and the data is unchanged. If the dataset is cleared or reloaded, the comparison list is reset.","title":"Behavior"},{"location":"fit/fit_comparison/#limitations","text":"Manual fits cannot be stored or compared. Fits are not saved between sessions. Only the best-fit curve is stored, not confidence intervals or MCMC traces.","title":"Limitations"},{"location":"fit/fit_formula/","text":"Fit Formula The Fit Formula defines the mathematical model used to fit experimental data. It is entered directly into the application using symbolic syntax inspired by SymPy , and parsed into executable Python code behind the scenes. Graphical Curve Fit for Python allows formulas to be written interactively in the interface, and automatically extracts all parameters to configure the fitting backend. Syntax and Supported Functions A formula must be a single line that starts with y = , for 1D data, or z = , for 2D surface fits. 1D Model Example y = a * sin(x) + b 2D Surface Model Example z = a * x + b * y + c The formula should: It must: Start with y= or z= Use one or two independent variables: x , or x and y Use standard Python-style operators ( * , + , - , / , ** for exponentiation) Use supported mathematical functions Supported functions These expressions are automatically translated to NumPy-compatible code: Function Description Translated to sin(x) sine np.sin(x) abs(x) absolute np.abs(x) cos(x) cosine np.cos(x) tan(x) tangent np.tan(x) exp(x) exponential np.exp(x) log(x) natural log (ln) np.log(x) log10(x) base-10 logarithm np.log10(x) sqrt(x) square root np.sqrt(x) arcsin inverse sine np.arcsin(x) arccos inverse cosine np.arccos(x) arctan inverse tangent np.arctan(x) sinh hyperbolic sine np.sinh(x) cosh hyperbolic cosine np.cosh(x) Constants You can use the following scientific constants directly in your formula: Name Meaning Value pi pi 3.14159\u2026 e0 Euler\u2019s number 2.71828\u2026 placnk Planck constant 6.626e-34 c0 Speed of light (m/s) 299792458 kB Boltzmann constant 1.380649e-23 eV Elementary charge (Coul.) 1.602176634e-19 These different parameters are in the \\gcfpy\\utils\\math_config.json Formula Parsing Once entered, the formula is internally parsed using: sympy to extract parameters and check validity ast for code transformation into valid NumPy-compatible Python If the formula is invalid or non-numeric, the system will display an error message. Parameter Extraction All symbolic parameters (like a , b , c ) are automatically extracted. excluding x , y , or z . The extracted parameters are used to: Define the fit_function The Fit Options panel, which allows setting initial values, bounds, and constraints See Fit Options for more details on parameter configuration. Importing a Formula You can import a previously saved fit function by clicking the Import Formula button. The file must contain a Python function of the form: import numpy as np def fit_function(x, a, b): return a * np.sin(x) + b The application parses the return line reconstructs the symbolic expression (e.g., y = a*sin(x) + b ). Exporting the Formula Click the Export Formula button to save the current expression as a .py file. The saved function will be compatible with Python and NumPy, and contain all constants used. Generated file: import numpy as np def fit_function(x, a, b): return a * np.sin(x) + b This function can be reused in other scripts or re-imported in the interface. Writing Your Own Function You can also write your own fit_function manually in a .py file. Just make sure: You name the function fit_function It accepts x or x, y as arguments, followed by all parameters Return a NumPy-compatible array Example: import numpy as np def fit_function(x, A, mu, sigma): return A * np.exp(-(x - mu)**2 / (2 * sigma**2)) For surface code: def fit_function(x, y, a, b, c): return a * x + b * y + c Notes Only one formula is used per fit tab The formula is reset if you load incompatible data Fit strategies (1D, Multi-Y, Surface) determine whether y= or z= is expected Formula and parameters can be adjusted live during the session","title":"Formula"},{"location":"fit/fit_formula/#fit-formula","text":"The Fit Formula defines the mathematical model used to fit experimental data. It is entered directly into the application using symbolic syntax inspired by SymPy , and parsed into executable Python code behind the scenes. Graphical Curve Fit for Python allows formulas to be written interactively in the interface, and automatically extracts all parameters to configure the fitting backend.","title":"Fit Formula"},{"location":"fit/fit_formula/#syntax-and-supported-functions","text":"A formula must be a single line that starts with y = , for 1D data, or z = , for 2D surface fits.","title":"Syntax and Supported Functions"},{"location":"fit/fit_formula/#1d-model-example","text":"y = a * sin(x) + b","title":"1D Model Example"},{"location":"fit/fit_formula/#2d-surface-model-example","text":"z = a * x + b * y + c The formula should: It must: Start with y= or z= Use one or two independent variables: x , or x and y Use standard Python-style operators ( * , + , - , / , ** for exponentiation) Use supported mathematical functions","title":"2D Surface Model Example"},{"location":"fit/fit_formula/#supported-functions","text":"These expressions are automatically translated to NumPy-compatible code: Function Description Translated to sin(x) sine np.sin(x) abs(x) absolute np.abs(x) cos(x) cosine np.cos(x) tan(x) tangent np.tan(x) exp(x) exponential np.exp(x) log(x) natural log (ln) np.log(x) log10(x) base-10 logarithm np.log10(x) sqrt(x) square root np.sqrt(x) arcsin inverse sine np.arcsin(x) arccos inverse cosine np.arccos(x) arctan inverse tangent np.arctan(x) sinh hyperbolic sine np.sinh(x) cosh hyperbolic cosine np.cosh(x)","title":"Supported functions"},{"location":"fit/fit_formula/#constants","text":"You can use the following scientific constants directly in your formula: Name Meaning Value pi pi 3.14159\u2026 e0 Euler\u2019s number 2.71828\u2026 placnk Planck constant 6.626e-34 c0 Speed of light (m/s) 299792458 kB Boltzmann constant 1.380649e-23 eV Elementary charge (Coul.) 1.602176634e-19 These different parameters are in the \\gcfpy\\utils\\math_config.json","title":"Constants"},{"location":"fit/fit_formula/#formula-parsing","text":"Once entered, the formula is internally parsed using: sympy to extract parameters and check validity ast for code transformation into valid NumPy-compatible Python If the formula is invalid or non-numeric, the system will display an error message.","title":"Formula Parsing"},{"location":"fit/fit_formula/#parameter-extraction","text":"All symbolic parameters (like a , b , c ) are automatically extracted. excluding x , y , or z . The extracted parameters are used to: Define the fit_function The Fit Options panel, which allows setting initial values, bounds, and constraints See Fit Options for more details on parameter configuration.","title":"Parameter Extraction"},{"location":"fit/fit_formula/#importing-a-formula","text":"You can import a previously saved fit function by clicking the Import Formula button. The file must contain a Python function of the form: import numpy as np def fit_function(x, a, b): return a * np.sin(x) + b The application parses the return line reconstructs the symbolic expression (e.g., y = a*sin(x) + b ).","title":"Importing a Formula"},{"location":"fit/fit_formula/#exporting-the-formula","text":"Click the Export Formula button to save the current expression as a .py file. The saved function will be compatible with Python and NumPy, and contain all constants used. Generated file: import numpy as np def fit_function(x, a, b): return a * np.sin(x) + b This function can be reused in other scripts or re-imported in the interface.","title":"Exporting the Formula"},{"location":"fit/fit_formula/#writing-your-own-function","text":"You can also write your own fit_function manually in a .py file. Just make sure: You name the function fit_function It accepts x or x, y as arguments, followed by all parameters Return a NumPy-compatible array Example: import numpy as np def fit_function(x, A, mu, sigma): return A * np.exp(-(x - mu)**2 / (2 * sigma**2)) For surface code: def fit_function(x, y, a, b, c): return a * x + b * y + c","title":"Writing Your Own Function"},{"location":"fit/fit_formula/#notes","text":"Only one formula is used per fit tab The formula is reset if you load incompatible data Fit strategies (1D, Multi-Y, Surface) determine whether y= or z= is expected Formula and parameters can be adjusted live during the session","title":"Notes"},{"location":"fit/fit_options/","text":"Fit Options The Fit Options dialog lets you configure all aspects of the fitting process, including method selection, parameter bounds, initial values, and optimizer-specific settings. It is automatically populated from the current formula, extracting each parameter symbolically and allowing you to customize how each is treated during the fit. Fit Method In the General Settings section, you can choose one of the following fitting methods: Levenberg-Marquardt ( leastsq )): Fast and commonly used for least-squares minimization. Orthogonal Distance Regression ( odr ): Useful when both x and y have associated uncertainties. MCMC ( emcee ): Bayesian sampling using Markov Chain Monte Carlo, returning posterior distributions. Each method enables different controls and outputs. Parameters Table This table lists all parameters extracted from the current formula. For each parameter, you can define: Setting Description Initial Value Starting guess used to initialize the fit Min / Max Lower and upper bounds (e.g., 0 to 10) These values are passed to the backend fitting engine and directly influence convergence. Optimizer-Specific Settings Below the parameter table, method-specific options appear based on the selected algorithm. Levenberg-Marquardt (leastsq) Option Description calc_covar Whether to compute the covariance matrix scale_covar Whether to rescale the covariance output xtol / ftol / gtol Tolerances for convergence These settings are passed to scipy.optimize.leastsq() via lmfit . MCMC ( emcee ): Option Description nwalkers Number of walkers (MCMC chains) steps Total number of sampling steps burn Burn-in steps to discard from the beginning thin Thinning factor to reduce autocorrelation is_weighted Whether to include y_err or sigma in the likelihood These options control the behavior of the emcee.EnsembleSampler . Notes The table updates automatically if the formula changes. Bounds and initial values are used by all fit methods, including MCMC priors. The fit options are saved per tab and reloaded when reopening a fit.","title":"Options"},{"location":"fit/fit_options/#fit-options","text":"The Fit Options dialog lets you configure all aspects of the fitting process, including method selection, parameter bounds, initial values, and optimizer-specific settings. It is automatically populated from the current formula, extracting each parameter symbolically and allowing you to customize how each is treated during the fit.","title":"Fit Options"},{"location":"fit/fit_options/#fit-method","text":"In the General Settings section, you can choose one of the following fitting methods: Levenberg-Marquardt ( leastsq )): Fast and commonly used for least-squares minimization. Orthogonal Distance Regression ( odr ): Useful when both x and y have associated uncertainties. MCMC ( emcee ): Bayesian sampling using Markov Chain Monte Carlo, returning posterior distributions. Each method enables different controls and outputs.","title":"Fit Method"},{"location":"fit/fit_options/#parameters-table","text":"This table lists all parameters extracted from the current formula. For each parameter, you can define: Setting Description Initial Value Starting guess used to initialize the fit Min / Max Lower and upper bounds (e.g., 0 to 10) These values are passed to the backend fitting engine and directly influence convergence.","title":"Parameters Table"},{"location":"fit/fit_options/#optimizer-specific-settings","text":"Below the parameter table, method-specific options appear based on the selected algorithm.","title":"Optimizer-Specific Settings"},{"location":"fit/fit_options/#levenberg-marquardt-leastsq","text":"Option Description calc_covar Whether to compute the covariance matrix scale_covar Whether to rescale the covariance output xtol / ftol / gtol Tolerances for convergence These settings are passed to scipy.optimize.leastsq() via lmfit .","title":"Levenberg-Marquardt (leastsq)"},{"location":"fit/fit_options/#mcmc-emcee","text":"Option Description nwalkers Number of walkers (MCMC chains) steps Total number of sampling steps burn Burn-in steps to discard from the beginning thin Thinning factor to reduce autocorrelation is_weighted Whether to include y_err or sigma in the likelihood These options control the behavior of the emcee.EnsembleSampler .","title":"MCMC (emcee):"},{"location":"fit/fit_options/#notes","text":"The table updates automatically if the formula changes. Bounds and initial values are used by all fit methods, including MCMC priors. The fit options are saved per tab and reloaded when reopening a fit.","title":"Notes"},{"location":"fit/manual/","text":"Manual Parameter Adjustment Manual adjustment mode provides interactive control over fitting parameters without using any optimization algorithm. It allows visual exploration of parameter influence and can be useful for testing model robustness, preparing initial values, or manually shaping the model to match the data. Overview When manual mode is enabled, a dedicated dock displays interactive sliders for each model parameter. As you move the sliders, the fitted curve updates in real-time. This mode is isolated from automated optimization and can be toggled on or off at any point. This mode is particularly useful: - To understand the effect of each parameter on the model - To prepare a better set of initial values (p0) before fitting - When exact values are known or imposed by physical constraints How to enable Manual Mode Manual mode is toggled from the Manual button in the main toolbar. Enabling it: Display the Manual Fit dock. Deactivates the Fit Control dock. Suspends all automated fitting and disables fit-related buttons. The Manual Fit Dock Sliders are generated dynamically based on the current model formula. Each parameter has: Initial value : The base value used in the formula. Range (min, max) : Optional boundaries to control the slider limits. Slider : You can drag to change the value in real-time. These values are either inferred from the formula or set manually. Every slider movement triggers an immediate update of the fit on the plot. Using Sliders Sliders are dynamically created based on the parameters detected in your fit formula. They are bounded by min/max values set manually or by default. The fit result updates automatically as you slide. Synchronization with Formula and Fit Options If the formula is changed or re-imported, all sliders are reset. Parameter names and initial values are re-parsed from the new formula. Any adjustment made manually is reflected in the Initial Value (p0) of the Fit Options dialog. Exiting Manual Mode To exit manual mode: - Click the Manual button again in the toolbar. - The Manual Fit dock is hidden. - The Fit Control dock is re-enabled. - Automated fitting becomes available again. Limitations Manual mode is subject to a few constraints: - Only continuous numeric parameters are supported. - Sliders are not saved between sessions. - Advanced models with multiple independent variables are not currently supported. - Manual adjustments are not tracked or recorded in the comparison manager.","title":"Manual Fit"},{"location":"fit/manual/#manual-parameter-adjustment","text":"Manual adjustment mode provides interactive control over fitting parameters without using any optimization algorithm. It allows visual exploration of parameter influence and can be useful for testing model robustness, preparing initial values, or manually shaping the model to match the data.","title":"Manual Parameter Adjustment"},{"location":"fit/manual/#overview","text":"When manual mode is enabled, a dedicated dock displays interactive sliders for each model parameter. As you move the sliders, the fitted curve updates in real-time. This mode is isolated from automated optimization and can be toggled on or off at any point. This mode is particularly useful: - To understand the effect of each parameter on the model - To prepare a better set of initial values (p0) before fitting - When exact values are known or imposed by physical constraints","title":"Overview"},{"location":"fit/manual/#how-to-enable-manual-mode","text":"Manual mode is toggled from the Manual button in the main toolbar. Enabling it: Display the Manual Fit dock. Deactivates the Fit Control dock. Suspends all automated fitting and disables fit-related buttons.","title":"How to enable Manual Mode"},{"location":"fit/manual/#the-manual-fit-dock","text":"Sliders are generated dynamically based on the current model formula. Each parameter has: Initial value : The base value used in the formula. Range (min, max) : Optional boundaries to control the slider limits. Slider : You can drag to change the value in real-time. These values are either inferred from the formula or set manually. Every slider movement triggers an immediate update of the fit on the plot.","title":"The Manual Fit Dock"},{"location":"fit/manual/#using-sliders","text":"Sliders are dynamically created based on the parameters detected in your fit formula. They are bounded by min/max values set manually or by default. The fit result updates automatically as you slide.","title":"Using Sliders"},{"location":"fit/manual/#synchronization-with-formula-and-fit-options","text":"If the formula is changed or re-imported, all sliders are reset. Parameter names and initial values are re-parsed from the new formula. Any adjustment made manually is reflected in the Initial Value (p0) of the Fit Options dialog.","title":"Synchronization with Formula and Fit Options"},{"location":"fit/manual/#exiting-manual-mode","text":"To exit manual mode: - Click the Manual button again in the toolbar. - The Manual Fit dock is hidden. - The Fit Control dock is re-enabled. - Automated fitting becomes available again.","title":"Exiting Manual Mode"},{"location":"fit/manual/#limitations","text":"Manual mode is subject to a few constraints: - Only continuous numeric parameters are supported. - Sliders are not saved between sessions. - Advanced models with multiple independent variables are not currently supported. - Manual adjustments are not tracked or recorded in the comparison manager.","title":"Limitations"},{"location":"fit/mcmc/","text":"MCMC Diagnostics and Visualization When fitting a model using the MCMC method (via emcee ), the application provides a set of dedicated plots and diagnostics tools to analyze the posterior distributions of the parameters. 1. MCMC Fit Plot Displays the median fit curve obtained from the posterior samples. A 99% confidence band (credible interval) is shown around the curve. 2. Corner Plot Shows the marginal and joint distributions of all model parameters. Each subplot provides histograms (diagonal) and 2D scatter plots (off-diagonal). Useful to assess parameter correlations, asymmetry. 3. Walkers Plot Plots the value of each parameter across sampling steps for all walkers. Helps diagnose convergence and detect sampling issues (e.g., stuck walkers). Walkers should appear well-mixed and stable after the burn-in period. 4. Autocorrelation Plot Displays the autocorrelation time of each parameter. Allows evaluation of sampling efficiency and helps determine appropriate thin or burn settings. Notes All MCMC diagnostics are computed after discarding the burn-in period. If convergence is poor, consider increasing the number of walkers or steps. You can export posterior samples or corner plots from the toolbar menu.","title":"MCMC"},{"location":"fit/mcmc/#mcmc-diagnostics-and-visualization","text":"When fitting a model using the MCMC method (via emcee ), the application provides a set of dedicated plots and diagnostics tools to analyze the posterior distributions of the parameters.","title":"MCMC Diagnostics and Visualization"},{"location":"fit/mcmc/#1-mcmc-fit-plot","text":"Displays the median fit curve obtained from the posterior samples. A 99% confidence band (credible interval) is shown around the curve.","title":"1. MCMC Fit Plot"},{"location":"fit/mcmc/#2-corner-plot","text":"Shows the marginal and joint distributions of all model parameters. Each subplot provides histograms (diagonal) and 2D scatter plots (off-diagonal). Useful to assess parameter correlations, asymmetry.","title":"2. Corner Plot"},{"location":"fit/mcmc/#3-walkers-plot","text":"Plots the value of each parameter across sampling steps for all walkers. Helps diagnose convergence and detect sampling issues (e.g., stuck walkers). Walkers should appear well-mixed and stable after the burn-in period.","title":"3. Walkers Plot"},{"location":"fit/mcmc/#4-autocorrelation-plot","text":"Displays the autocorrelation time of each parameter. Allows evaluation of sampling efficiency and helps determine appropriate thin or burn settings.","title":"4. Autocorrelation Plot"},{"location":"fit/mcmc/#notes","text":"All MCMC diagnostics are computed after discarding the burn-in period. If convergence is poor, consider increasing the number of walkers or steps. You can export posterior samples or corner plots from the toolbar menu.","title":"Notes"},{"location":"fit/results/","text":"Fit Results After a fitting process is completed, the application displays a full summary of the result, both numerically and graphically. This section describes each type of output available through the Results Dock and plot area. 1. Numerical Summary The Results Dock shows detailed outputs such as: Fit Report : Lists all estimated parameters along with their: Best-fit values Standard errors (\u00b1) Units if available Correlation matrix (if applicable) Statistical Metrics : Chi-square (\u03c7\u00b2) : Total squared residuals, weighted if errors are given. Reduced \u03c7\u00b2 : \u03c7\u00b2 normalized by the degrees of freedom. Akaike Information Criterion (AIC) and Bayesian Information Criterion (BIC) : Used to compare models by balancing error and complexity. Root Mean Square Error (RMSE) : Square root of the mean squared residuals. R\u00b2 (coefficient of determination): Fraction of variance explained by the model. These values are updated immediately after any fit and can help assess the quality and reliability of the result. 2. Graphical Summary The graphical representation is organized into multiple tabs in the Plot Area : Fit Plot Displays the original data and fitted model curve. When component decomposition is enabled, individual terms of the formula (e.g., separate Gaussians) are overlaid. Residuals Plot Shows data - fit to identify systematic discrepancies. Confidence Band Visualizes uncertainty on the model as a shaded region (3sigma). This requires confidence interval computation to be active. Decomposition Plot Plots the individual terms of the symbolic model. This helps understand the role of each component. 2D Confidence Contours Displays elliptical regions in parameter space to illustrate correlations between pairs of parameters. Only available for fits made by lmfit.","title":"Fit Result"},{"location":"fit/results/#fit-results","text":"After a fitting process is completed, the application displays a full summary of the result, both numerically and graphically. This section describes each type of output available through the Results Dock and plot area.","title":"Fit Results"},{"location":"fit/results/#1-numerical-summary","text":"The Results Dock shows detailed outputs such as: Fit Report : Lists all estimated parameters along with their: Best-fit values Standard errors (\u00b1) Units if available Correlation matrix (if applicable) Statistical Metrics : Chi-square (\u03c7\u00b2) : Total squared residuals, weighted if errors are given. Reduced \u03c7\u00b2 : \u03c7\u00b2 normalized by the degrees of freedom. Akaike Information Criterion (AIC) and Bayesian Information Criterion (BIC) : Used to compare models by balancing error and complexity. Root Mean Square Error (RMSE) : Square root of the mean squared residuals. R\u00b2 (coefficient of determination): Fraction of variance explained by the model. These values are updated immediately after any fit and can help assess the quality and reliability of the result.","title":"1. Numerical Summary"},{"location":"fit/results/#2-graphical-summary","text":"The graphical representation is organized into multiple tabs in the Plot Area : Fit Plot Displays the original data and fitted model curve. When component decomposition is enabled, individual terms of the formula (e.g., separate Gaussians) are overlaid. Residuals Plot Shows data - fit to identify systematic discrepancies. Confidence Band Visualizes uncertainty on the model as a shaded region (3sigma). This requires confidence interval computation to be active. Decomposition Plot Plots the individual terms of the symbolic model. This helps understand the role of each component. 2D Confidence Contours Displays elliptical regions in parameter space to illustrate correlations between pairs of parameters. Only available for fits made by lmfit.","title":"2. Graphical Summary"},{"location":"tutorials/2d_fit/","text":"Fitting a 2D Surface This tutorial demonstrates how to use the 2D surface fitting mode to fit a model to data defined over a 2D grid. This is useful when your measurements depend simultaneously on two variables, and the response surface can be described by a global model of the form $z = f(x, y)$. Step 1 \u2013 Load the data Use File > Load Data and select: examples/data/surface_fit_tuto.csv This dataset includes: X : the first independent variable Y : the second independent variable Z : the observed value at each (X, Y) point After loading, the application automatically switches to 2D mode , and the Fit Strategy selector appears in the control dock. Select the strategy: Fit surface (Z = f(X, Y)) Step 2 \u2013 Define the formula We use a 2D Gaussian surface combined with an interaction term: z = A * exp(-((x - B)**2 + (y - C)**2) / (2 * D**2)) + E * x * y This model contains five parameters: A : amplitude of the Gaussian peak B : center position along X C : center position along Y D : width of the Gaussian E : interaction term that introduces a cross-dependence between X and Y This formula is global: it is fitted to all points simultaneously. Step 3 \u2013 Run the fit Click Fit in the fit control dock. The application will: Fit all data points using the selected method (default: lmfit ) Display the raw data and fitted surface in a 3D view with crosses for data and a surface for the fit You can also switch to alternative methods: odr for orthogonal error regression emcee for Bayesian sampling For emcee, it\u2019s often recommended to first run a classical fit to initialize the parameters. Notes This 2D surface fitting mode assumes that all variables x , y , and z are numeric and that the formula defines a continuous surface. Avoid sharp discontinuities or piecewise expressions when using this strategy.","title":"2D fot"},{"location":"tutorials/2d_fit/#fitting-a-2d-surface","text":"This tutorial demonstrates how to use the 2D surface fitting mode to fit a model to data defined over a 2D grid. This is useful when your measurements depend simultaneously on two variables, and the response surface can be described by a global model of the form $z = f(x, y)$.","title":"Fitting a 2D Surface"},{"location":"tutorials/2d_fit/#step-1-load-the-data","text":"Use File > Load Data and select: examples/data/surface_fit_tuto.csv This dataset includes: X : the first independent variable Y : the second independent variable Z : the observed value at each (X, Y) point After loading, the application automatically switches to 2D mode , and the Fit Strategy selector appears in the control dock. Select the strategy: Fit surface (Z = f(X, Y))","title":"Step 1 \u2013 Load the data"},{"location":"tutorials/2d_fit/#step-2-define-the-formula","text":"We use a 2D Gaussian surface combined with an interaction term: z = A * exp(-((x - B)**2 + (y - C)**2) / (2 * D**2)) + E * x * y This model contains five parameters: A : amplitude of the Gaussian peak B : center position along X C : center position along Y D : width of the Gaussian E : interaction term that introduces a cross-dependence between X and Y This formula is global: it is fitted to all points simultaneously.","title":"Step 2 \u2013 Define the formula"},{"location":"tutorials/2d_fit/#step-3-run-the-fit","text":"Click Fit in the fit control dock. The application will: Fit all data points using the selected method (default: lmfit ) Display the raw data and fitted surface in a 3D view with crosses for data and a surface for the fit You can also switch to alternative methods: odr for orthogonal error regression emcee for Bayesian sampling For emcee, it\u2019s often recommended to first run a classical fit to initialize the parameters.","title":"Step 3 \u2013 Run the fit"},{"location":"tutorials/2d_fit/#notes","text":"This 2D surface fitting mode assumes that all variables x , y , and z are numeric and that the formula defines a continuous surface. Avoid sharp discontinuities or piecewise expressions when using this strategy.","title":"Notes"},{"location":"tutorials/basic_fit/","text":"Basic 1D Fit This tutorial walks through the essential steps to perform a basic 1D fit using the Graphical Curve Fit for Python application. It is designed for first-time users to become familiar with the core workflow: loading data, defining a model, fitting, and analyzing the results. Step 1 \u2013 Load Example Data Launch the application: bash gcfpy Go to File > Load Data Select the file: examples/data/linear.csv Two docks will appear: X/Y Data : showing the raw data Fit Control : tools to launch and manage fits Step 2 \u2013 Enter a Fit Formula A formula is automatically added to the fit formula dock: y = a * x + b The application automatically extracts the parameters ( a , b ) and sets them up for fitting. You may also use built-in functions like sin , exp , log , and physical constants such as pi , e , h , etc. Step 3 \u2013 Configure Fit Options (Optional) Open the Fit Options dialog if you want to: Set initial guesses for a and b Define bounds Choose a different optimizer (default is leastsq ) This step is optional \u2013 default values will work for most basic examples. Step 4 \u2013 Run the Fit Press the Run Fit button in the Fit Control dock Upon completion, the following are updated: Results Dock : fitted values, standard errors, and metrics (AIC, BIC, RMSE, etc.) Plot : displays the best-fit line","title":"Basic"},{"location":"tutorials/basic_fit/#basic-1d-fit","text":"This tutorial walks through the essential steps to perform a basic 1D fit using the Graphical Curve Fit for Python application. It is designed for first-time users to become familiar with the core workflow: loading data, defining a model, fitting, and analyzing the results.","title":"Basic 1D Fit"},{"location":"tutorials/basic_fit/#step-1-load-example-data","text":"Launch the application: bash gcfpy Go to File > Load Data Select the file: examples/data/linear.csv Two docks will appear: X/Y Data : showing the raw data Fit Control : tools to launch and manage fits","title":"Step 1 \u2013 Load Example Data"},{"location":"tutorials/basic_fit/#_1","text":"","title":""},{"location":"tutorials/basic_fit/#step-2-enter-a-fit-formula","text":"A formula is automatically added to the fit formula dock: y = a * x + b The application automatically extracts the parameters ( a , b ) and sets them up for fitting. You may also use built-in functions like sin , exp , log , and physical constants such as pi , e , h , etc.","title":"Step 2 \u2013 Enter a Fit Formula"},{"location":"tutorials/basic_fit/#step-3-configure-fit-options-optional","text":"Open the Fit Options dialog if you want to: Set initial guesses for a and b Define bounds Choose a different optimizer (default is leastsq ) This step is optional \u2013 default values will work for most basic examples.","title":"Step 3 \u2013 Configure Fit Options (Optional)"},{"location":"tutorials/basic_fit/#step-4-run-the-fit","text":"Press the Run Fit button in the Fit Control dock Upon completion, the following are updated: Results Dock : fitted values, standard errors, and metrics (AIC, BIC, RMSE, etc.) Plot : displays the best-fit line","title":"Step 4 \u2013 Run the Fit"},{"location":"tutorials/comparison/","text":"Fitting Comparison \u2013 1D Models This tutorial demonstrates how to compare multiple candidate models using the fit comparison tool . This feature is designed to help evaluate and visualize which mathematical expression best explains your data. Step 1 \u2013 Load the data Use File > Load Data and select: examples/data/fit_comparison_tuto.csv This dataset contains: X : the independent variable Y : the observed values It represents a 1D curve with moderate noise and nonlinear behavior. Step 2 \u2013 Add a first model Go to the Fit Formula dock and enter the following expression: A * exp(-B * x) Click Add Fit to save this model for later comparison. This first model assumes a pure exponential decay. Step 3 \u2013 Add a second model Replace the formula with a more complex version: A * exp(-B * x) + C * sin(D * x) Click Add Fit again. This second model introduces an oscillatory correction that may better match the residual pattern. Step 4 \u2013 Add a third (invalid) model Try a deliberately simplistic model: a * x + b Click Add Fit once more. This third model should illustrate a poor fit, helping users see what a mismatch looks like visually and statistically. Step 5 \u2013 View and compare results Click the Compare button in the toolbar or use the shortcut: In the comparison dock, you\u2019ll find: Overlayed plots of all models and the original data Residuals for each model Fit quality metrics (e.g. AIC, R\u00b2, RMSE) A table listing parameter values per model Step 6 \u2013 Interpret the outcome Look for the model that: Best visually aligns with the data Produces minimal, random-looking residuals Has lower AIC or RMSE values In this case, the second model ( exp + sin ) should outperform the others. For a better view, you can click on the checkbox next to the fit to hide it. You can also change the name of the fit by double-clicking on the name of the fit next to the change name chechkbox and pressing enter. This will change the name in the figure legend and in the comparison table. Notes You can add as many models as needed \u2014 each remains listed and comparable Use the Fit Report dock to examine details per model Models can be re-fit or removed at any time from the list","title":"Comparison"},{"location":"tutorials/comparison/#fitting-comparison-1d-models","text":"This tutorial demonstrates how to compare multiple candidate models using the fit comparison tool . This feature is designed to help evaluate and visualize which mathematical expression best explains your data.","title":"Fitting Comparison \u2013 1D Models"},{"location":"tutorials/comparison/#step-1-load-the-data","text":"Use File > Load Data and select: examples/data/fit_comparison_tuto.csv This dataset contains: X : the independent variable Y : the observed values It represents a 1D curve with moderate noise and nonlinear behavior.","title":"Step 1 \u2013 Load the data"},{"location":"tutorials/comparison/#step-2-add-a-first-model","text":"Go to the Fit Formula dock and enter the following expression: A * exp(-B * x) Click Add Fit to save this model for later comparison. This first model assumes a pure exponential decay.","title":"Step 2 \u2013 Add a first model"},{"location":"tutorials/comparison/#step-3-add-a-second-model","text":"Replace the formula with a more complex version: A * exp(-B * x) + C * sin(D * x) Click Add Fit again. This second model introduces an oscillatory correction that may better match the residual pattern.","title":"Step 3 \u2013 Add a second model"},{"location":"tutorials/comparison/#step-4-add-a-third-invalid-model","text":"Try a deliberately simplistic model: a * x + b Click Add Fit once more. This third model should illustrate a poor fit, helping users see what a mismatch looks like visually and statistically.","title":"Step 4 \u2013 Add a third (invalid) model"},{"location":"tutorials/comparison/#step-5-view-and-compare-results","text":"Click the Compare button in the toolbar or use the shortcut: In the comparison dock, you\u2019ll find: Overlayed plots of all models and the original data Residuals for each model Fit quality metrics (e.g. AIC, R\u00b2, RMSE) A table listing parameter values per model","title":"Step 5 \u2013 View and compare results"},{"location":"tutorials/comparison/#step-6-interpret-the-outcome","text":"Look for the model that: Best visually aligns with the data Produces minimal, random-looking residuals Has lower AIC or RMSE values In this case, the second model ( exp + sin ) should outperform the others. For a better view, you can click on the checkbox next to the fit to hide it. You can also change the name of the fit by double-clicking on the name of the fit next to the change name chechkbox and pressing enter. This will change the name in the figure legend and in the comparison table.","title":"Step 6 \u2013 Interpret the outcome"},{"location":"tutorials/comparison/#notes","text":"You can add as many models as needed \u2014 each remains listed and comparable Use the Fit Report dock to examine details per model Models can be re-fit or removed at any time from the list","title":"Notes"},{"location":"tutorials/manual_fit/","text":"Manual Fitting Mode This tutorial introduces the manual mode , which allows you to visualize the effect of a formula and manually adjust its parameters using sliders \u2014 without launching an automatic fit. This mode is ideal for verifying formulas, exploring parameter behavior, and setting good initial guesses. Step 1 \u2013 Load the data Use File > Load Data and select: examples/data/manual_fit_tuto.csv This dataset includes: X : the main sweep variable Y : a secondary index (discrete) Z : the observed value for each (X, Y) After loading, the application automatically enters Fit per Y and displays a set of curves indexed by Y. There is no manual mode for 3d plots Step 2 \u2013 Switch to manual mode In the Fit Control dock, click: Manual This disables the \"Fit\" button and instead activates a slider interface for parameter adjustment. This allows real-time manipulation of parameters without optimization. Step 3 \u2013 Define a formula Try the following example: z = A * sin(B * x + C) + D * y Once entered, sliders appear for each parameter ( A , B , C , D ). You can now adjust them manually. Use the slider to change the value of the parameter The limits can be changed by clicking on the values at the ends of the sliders Step 4 \u2013 Adjust the sliders Each slider updates the plot in real time . You can: See how each parameter influences the curve Explore how well the formula matches the data visually Zoom/pan to inspect features in detail If in 2D mode (i.e. Y is present), a curve is displayed for each value of Y . Step 5 \u2013 Use it to set initial guesses Once a visually good match is found: Switch to a fitting method such as lmfit , odr , or emcee The last slider values are retained as the initial guesses Click Fit to run the optimization from that point This can significantly improve convergence and avoid local minima. Why use manual mode? Quickly verify that the formula is well-formed Understand parameter roles and interactions Pre-tune parameters for faster and more accurate fitting Compare models before choosing one","title":"Manual"},{"location":"tutorials/manual_fit/#manual-fitting-mode","text":"This tutorial introduces the manual mode , which allows you to visualize the effect of a formula and manually adjust its parameters using sliders \u2014 without launching an automatic fit. This mode is ideal for verifying formulas, exploring parameter behavior, and setting good initial guesses.","title":"Manual Fitting Mode"},{"location":"tutorials/manual_fit/#step-1-load-the-data","text":"Use File > Load Data and select: examples/data/manual_fit_tuto.csv This dataset includes: X : the main sweep variable Y : a secondary index (discrete) Z : the observed value for each (X, Y) After loading, the application automatically enters Fit per Y and displays a set of curves indexed by Y. There is no manual mode for 3d plots","title":"Step 1 \u2013 Load the data"},{"location":"tutorials/manual_fit/#step-2-switch-to-manual-mode","text":"In the Fit Control dock, click: Manual This disables the \"Fit\" button and instead activates a slider interface for parameter adjustment. This allows real-time manipulation of parameters without optimization.","title":"Step 2 \u2013 Switch to manual mode"},{"location":"tutorials/manual_fit/#step-3-define-a-formula","text":"Try the following example: z = A * sin(B * x + C) + D * y Once entered, sliders appear for each parameter ( A , B , C , D ). You can now adjust them manually. Use the slider to change the value of the parameter The limits can be changed by clicking on the values at the ends of the sliders","title":"Step 3 \u2013 Define a formula"},{"location":"tutorials/manual_fit/#step-4-adjust-the-sliders","text":"Each slider updates the plot in real time . You can: See how each parameter influences the curve Explore how well the formula matches the data visually Zoom/pan to inspect features in detail If in 2D mode (i.e. Y is present), a curve is displayed for each value of Y .","title":"Step 4 \u2013 Adjust the sliders"},{"location":"tutorials/manual_fit/#step-5-use-it-to-set-initial-guesses","text":"Once a visually good match is found: Switch to a fitting method such as lmfit , odr , or emcee The last slider values are retained as the initial guesses Click Fit to run the optimization from that point This can significantly improve convergence and avoid local minima.","title":"Step 5 \u2013 Use it to set initial guesses"},{"location":"tutorials/manual_fit/#why-use-manual-mode","text":"Quickly verify that the formula is well-formed Understand parameter roles and interactions Pre-tune parameters for faster and more accurate fitting Compare models before choosing one","title":"Why use manual mode?"},{"location":"tutorials/mcmc/","text":"MCMC Fit (using emcee ) This tutorial demonstrates how to perform a fit using the MCMC backend ( emcee ) and how to interpret the associated diagnostic plots. Unlike classical optimizers such as lmfit or scipy.odr , the emcee sampler generates a distribution of parameter values rather than a single best-fit solution. This enables a deeper analysis of parameter uncertainties and correlations. Note : The visualizations described in this section are only available when using the MCMC method. 1. Load the Data Begin by opening the application and loading the dataset: examples/data/two_gaussians_with_slope.csv This file contains a signal composed of two Gaussians peak and a linear trend. If desired, you can restrict the fitting range using the Xmin/Xmax tool in the toolbar. 2. Define the Model In the Fit Formula dock, enter the following expression: y = p0 * exp(-0.5 * ((x - p1) / p2)**2) + p3 * exp(-0.5 * ((x - p4) / p5)**2) + p6 * x + p7 This model combines two Gaussians functions with a slope and offset. Tip: Run a Classical Fit First Before switching to MCMC, it is strongly recommended to run a preliminary fit using a classical method (e.g. leastsq ). This provides a good estimate of the initial parameter values. MCMC sampling is sensitive to the starting point. Starting from uninitialized or poorly chosen values may cause: Slow convergence Divergence of walkers Inefficient exploration of the parameter space By running a classical fit first, the initial guess ( p0 ) used by emcee will be closer to the region of interest, leading to faster and more stable results. You can then reopen the Fit Options , switch to emcee , and run the MCMC sampling using the values obtained from the initial fit. 3. Set the Fit Options Click the Fit Options button to open the configuration dialog. Go to the Genral options tab. Select emcee as the fitting method Recommended MCMC parameters: nwalkers : 100 steps : 1000 burn : 200 thin : 5 Enable is_weighted if your dataset includes Y_err Click OK to confirm. 4. Run the Fit Click the Fit button in the toolbar. Once the sampling is complete, the application will update the Results Dock and display the relevant plots. 5. MCMC Diagnostic Plots Four types of plots are generated automatically: Confidence Band The median model curve is displayed. A shaded region represents the 99% confidence interval. This interval is computed using percentiles over 500 randomly selected samples. Corner Plot Shows marginal and joint posterior distributions for all parameters. Useful to evaluate uncertainty and parameter correlations. Walkers Plot Each walker trajectory is plotted per parameter. Helps assess convergence and sample mixing. Autocorrelation Displays the autocorrelation as a function of lag for each parameter. Helps estimate the effective sample size.","title":"Plots mcmc"},{"location":"tutorials/mcmc/#mcmc-fit-using-emcee","text":"This tutorial demonstrates how to perform a fit using the MCMC backend ( emcee ) and how to interpret the associated diagnostic plots. Unlike classical optimizers such as lmfit or scipy.odr , the emcee sampler generates a distribution of parameter values rather than a single best-fit solution. This enables a deeper analysis of parameter uncertainties and correlations. Note : The visualizations described in this section are only available when using the MCMC method.","title":"MCMC Fit (using emcee)"},{"location":"tutorials/mcmc/#1-load-the-data","text":"Begin by opening the application and loading the dataset: examples/data/two_gaussians_with_slope.csv This file contains a signal composed of two Gaussians peak and a linear trend. If desired, you can restrict the fitting range using the Xmin/Xmax tool in the toolbar.","title":"1. Load the Data"},{"location":"tutorials/mcmc/#2-define-the-model","text":"In the Fit Formula dock, enter the following expression: y = p0 * exp(-0.5 * ((x - p1) / p2)**2) + p3 * exp(-0.5 * ((x - p4) / p5)**2) + p6 * x + p7 This model combines two Gaussians functions with a slope and offset.","title":"2. Define the Model"},{"location":"tutorials/mcmc/#tip-run-a-classical-fit-first","text":"Before switching to MCMC, it is strongly recommended to run a preliminary fit using a classical method (e.g. leastsq ). This provides a good estimate of the initial parameter values. MCMC sampling is sensitive to the starting point. Starting from uninitialized or poorly chosen values may cause: Slow convergence Divergence of walkers Inefficient exploration of the parameter space By running a classical fit first, the initial guess ( p0 ) used by emcee will be closer to the region of interest, leading to faster and more stable results. You can then reopen the Fit Options , switch to emcee , and run the MCMC sampling using the values obtained from the initial fit.","title":"Tip: Run a Classical Fit First"},{"location":"tutorials/mcmc/#3-set-the-fit-options","text":"Click the Fit Options button to open the configuration dialog. Go to the Genral options tab. Select emcee as the fitting method Recommended MCMC parameters: nwalkers : 100 steps : 1000 burn : 200 thin : 5 Enable is_weighted if your dataset includes Y_err Click OK to confirm.","title":"3. Set the Fit Options"},{"location":"tutorials/mcmc/#4-run-the-fit","text":"Click the Fit button in the toolbar. Once the sampling is complete, the application will update the Results Dock and display the relevant plots.","title":"4. Run the Fit"},{"location":"tutorials/mcmc/#5-mcmc-diagnostic-plots","text":"Four types of plots are generated automatically:","title":"5. MCMC Diagnostic Plots"},{"location":"tutorials/mcmc/#confidence-band","text":"The median model curve is displayed. A shaded region represents the 99% confidence interval. This interval is computed using percentiles over 500 randomly selected samples.","title":"Confidence Band"},{"location":"tutorials/mcmc/#corner-plot","text":"Shows marginal and joint posterior distributions for all parameters. Useful to evaluate uncertainty and parameter correlations.","title":"Corner Plot"},{"location":"tutorials/mcmc/#walkers-plot","text":"Each walker trajectory is plotted per parameter. Helps assess convergence and sample mixing.","title":"Walkers Plot"},{"location":"tutorials/mcmc/#autocorrelation","text":"Displays the autocorrelation as a function of lag for each parameter. Helps estimate the effective sample size.","title":"Autocorrelation"},{"location":"tutorials/multi_1d/","text":"Fitting Multiple 1D Curves This tutorial demonstrates how to use the multi 1D mode (\"Fit per Y\") to fit a model to a dataset composed of several 1D curves \\(Z = f(X)\\) at different values of \\(Y\\) . This is useful when performing measurements over a sweep of control parameters and assuming a global model structure across curves. Step 1 \u2013 Load the data Use File > Load Data and select: examples/data/multi1d_fit_tuto.csv This dataset includes: X : the sweep variable Y : the secondary index Z : the observed value for each combination of (X, Y) After loading, the application automatically switches to 2D mode , and the Fit Strategy selector appears in the control dock. Select the strategy: Fit per Y (multi 1D) Step 2 \u2013 Define the formula We choose a Gaussian function with a linear baseline: z = a * exp( -0.5 * (( x - ( b * y )) / ( c + d * y )) **2 )/(( c + d * y ))+ e * y The formula must contain both x and y . In multi-1D mode, y is treated as a fixed variable for each slice of data. If the formula does not include y, the fit will fail or produce incorrect results. This model will be applied to each Y-slice (i.e., to each \\(Z = f(X)\\) curve) using a global fit : all data points across all Y are used, but each Y is treated as an independent instance of the model. Step 3 \u2013 Run the fit Click Fit in the fit control dock. The application will: Fit all curves jointly using the selected method (default: lmfit ) Display one curve per Y in the Data + Fit tab Enable 1D confidence bands and residuals for each curve You can also change the method to: odr for orthogonal error regression emcee for Bayesian sampling If using emcee, it's recommended to first run a classical fit to improve convergence. Step 4 \u2013 Explore the results Use the toolbar or right-click menu to display: 99% Confidence Interval for each curve Residuals (difference between data and fit) 2D Contours : For emcee fits, posterior correlations between parameters Fit Report : Dock displaying values of the parameters and goodness-of-fit metrics Notes The model assumes each curve follows the same formula (same parameters across all Y)","title":"Multi 1D"},{"location":"tutorials/multi_1d/#fitting-multiple-1d-curves","text":"This tutorial demonstrates how to use the multi 1D mode (\"Fit per Y\") to fit a model to a dataset composed of several 1D curves \\(Z = f(X)\\) at different values of \\(Y\\) . This is useful when performing measurements over a sweep of control parameters and assuming a global model structure across curves.","title":"Fitting Multiple 1D Curves"},{"location":"tutorials/multi_1d/#step-1-load-the-data","text":"Use File > Load Data and select: examples/data/multi1d_fit_tuto.csv This dataset includes: X : the sweep variable Y : the secondary index Z : the observed value for each combination of (X, Y) After loading, the application automatically switches to 2D mode , and the Fit Strategy selector appears in the control dock. Select the strategy: Fit per Y (multi 1D)","title":"Step 1 \u2013 Load the data"},{"location":"tutorials/multi_1d/#step-2-define-the-formula","text":"We choose a Gaussian function with a linear baseline: z = a * exp( -0.5 * (( x - ( b * y )) / ( c + d * y )) **2 )/(( c + d * y ))+ e * y The formula must contain both x and y . In multi-1D mode, y is treated as a fixed variable for each slice of data. If the formula does not include y, the fit will fail or produce incorrect results. This model will be applied to each Y-slice (i.e., to each \\(Z = f(X)\\) curve) using a global fit : all data points across all Y are used, but each Y is treated as an independent instance of the model.","title":"Step 2 \u2013 Define the formula"},{"location":"tutorials/multi_1d/#step-3-run-the-fit","text":"Click Fit in the fit control dock. The application will: Fit all curves jointly using the selected method (default: lmfit ) Display one curve per Y in the Data + Fit tab Enable 1D confidence bands and residuals for each curve You can also change the method to: odr for orthogonal error regression emcee for Bayesian sampling If using emcee, it's recommended to first run a classical fit to improve convergence.","title":"Step 3 \u2013 Run the fit"},{"location":"tutorials/multi_1d/#step-4-explore-the-results","text":"Use the toolbar or right-click menu to display: 99% Confidence Interval for each curve Residuals (difference between data and fit) 2D Contours : For emcee fits, posterior correlations between parameters Fit Report : Dock displaying values of the parameters and goodness-of-fit metrics","title":"Step 4 \u2013 Explore the results"},{"location":"tutorials/multi_1d/#notes","text":"The model assumes each curve follows the same formula (same parameters across all Y)","title":"Notes"},{"location":"tutorials/plots/","text":"Fit Plots (Least Squares & ODR) This tutorial presents the available post-fit plots when using least squares ( lmfit ) or orthogonal distance regression ( odr ). These diagnostics are not available when using MCMC ( emcee ), which has its own visualizations. We will load a sample dataset consisting of two Gaussian peaks and a linear background, restrict the fit range using Xmin/Xmax, and explore: 99% confidence bands Residuals Model decomposition 2D parameter correlation contours (not avaible with odr ) 1. Load the Data Use the menu File > Load Data and select: examples/data/double_gaussian_with_slope.csv The data will be automatically plotted, and the table will be filled. 2. Apply Xmin/Xmax Selection Click the Xmin/Xmax button in the toolbar. Click twice on the plot to define the domain to fit The shaded area will indicate the active region This allows excluding noisy or irrelevant parts of the dataset. 3. Define the Formula In the Fit Formula dock, enter: y = p0 * exp(-0.5 * ((x - p1)/p2)**2) + p3 * x + p4 All parameters are initialized to 0 by default. You can manually set initial values or use the Fit Options panel to configure them. 4. Run the Fit In the Fit Control dock: Select General Options tab Select a method (except emcee) Click Run Fit This will produce the main fit curve and open the Fit Results dock. 5. Visualize the Fit Once the fit is complete, you can activate various diagnostics via the toolbar: a. 99% Confidence Band Enable the Confidence Interval icon. A shaded region appears around the fit Indicates uncertainty based on parameter covariance b. Residuals Plot Click the Residuals icon. Opens a Data\u2013Fit residuals tab below the main plot Displays the deviation between experimental data and fitted curve, helping detect systematic errors or poor model agreement c. Decomposition Plot Click the Fit decomposition icon. Displays individual model terms (Gaussian + slope) Useful for understanding each contribution d. 2D Parameter Contours Enable the 2D Contour icon. Shows contour plots of parameter correlations Especially useful to detect strong dependencies","title":"Plots lmfit/odr"},{"location":"tutorials/plots/#fit-plots-least-squares-odr","text":"This tutorial presents the available post-fit plots when using least squares ( lmfit ) or orthogonal distance regression ( odr ). These diagnostics are not available when using MCMC ( emcee ), which has its own visualizations. We will load a sample dataset consisting of two Gaussian peaks and a linear background, restrict the fit range using Xmin/Xmax, and explore: 99% confidence bands Residuals Model decomposition 2D parameter correlation contours (not avaible with odr )","title":"Fit Plots (Least Squares &amp; ODR)"},{"location":"tutorials/plots/#1-load-the-data","text":"Use the menu File > Load Data and select: examples/data/double_gaussian_with_slope.csv The data will be automatically plotted, and the table will be filled.","title":"1. Load the Data"},{"location":"tutorials/plots/#2-apply-xminxmax-selection","text":"Click the Xmin/Xmax button in the toolbar. Click twice on the plot to define the domain to fit The shaded area will indicate the active region This allows excluding noisy or irrelevant parts of the dataset.","title":"2. Apply Xmin/Xmax Selection"},{"location":"tutorials/plots/#3-define-the-formula","text":"In the Fit Formula dock, enter: y = p0 * exp(-0.5 * ((x - p1)/p2)**2) + p3 * x + p4 All parameters are initialized to 0 by default. You can manually set initial values or use the Fit Options panel to configure them.","title":"3. Define the Formula"},{"location":"tutorials/plots/#4-run-the-fit","text":"In the Fit Control dock: Select General Options tab Select a method (except emcee) Click Run Fit This will produce the main fit curve and open the Fit Results dock.","title":"4. Run the Fit"},{"location":"tutorials/plots/#5-visualize-the-fit","text":"Once the fit is complete, you can activate various diagnostics via the toolbar:","title":"5. Visualize the Fit"},{"location":"tutorials/plots/#a-99-confidence-band","text":"Enable the Confidence Interval icon. A shaded region appears around the fit Indicates uncertainty based on parameter covariance","title":"a. 99% Confidence Band"},{"location":"tutorials/plots/#b-residuals-plot","text":"Click the Residuals icon. Opens a Data\u2013Fit residuals tab below the main plot Displays the deviation between experimental data and fitted curve, helping detect systematic errors or poor model agreement","title":"b. Residuals Plot"},{"location":"tutorials/plots/#c-decomposition-plot","text":"Click the Fit decomposition icon. Displays individual model terms (Gaussian + slope) Useful for understanding each contribution","title":"c. Decomposition Plot"},{"location":"tutorials/plots/#d-2d-parameter-contours","text":"Enable the 2D Contour icon. Shows contour plots of parameter correlations Especially useful to detect strong dependencies","title":"d. 2D Parameter Contours"},{"location":"ui/docks/","text":"Dock Widgets Dock widgets are key components of the graphical interface. Each one provides a specific view or control for fitting, plotting, or data inspection. Docks can be hidden, or restored via the View menu. Overview By default, the following dock widgets are available in each fitting tab: Dock Name Purpose Fit Formula Enter and edit the fitting equation Fit Results Display fit report and estimated parameters Manual Control Adjust parameters manually with sliders X/Y Data Inspect the loaded dataset in tabular form Plot Area Visualize raw data, fits, and diagnostics 1. Fit Formula Allows symbolic definition of the model using a Python-like syntax. Formula must start with y = , e.g., y = a * x + b . Parameters are automatically extracted and synchronized with the Fit Options. Functions like exp , log , sin , abs , and physical constants can be used. Actions: Import or export formulas Open the Fit Options window Update formula dynamically with the fit mode (1D, 2D) 2. Fit Results Displays results after fitting: Best-fit values Confidence intervals Goodness-of-fit metrics (e.g., \u03c7\u00b2, R\u00b2) Updated live after each fit Hidden until a fit is completed 3. Manual Control Provides sliders to control parameter values manually. Useful for visually exploring parameter space or preparing a good initial guess. Can be toggled from the toolbar. Automatically updates the plot in real time. 4. X/Y Data Displays the currently loaded dataset in table format. Adapts to data content (1D or 2D): Shows X , Y , and optionally Z , X_err , Y_err , Z_err . Allows user to inspect data before fitting. Automatically appears after loading a valid file. 5. Plot Area Central area for displaying: Raw data Fitted curve Residuals Confidence bands Decomposed components Interacts with toolbar toggles Automatically updated after data load or fit execution Managing Docks Docks can be moved, closed, or rearranged freely. Use View > Restore Default Layout to reset the layout. Visibility of individual docks can be toggled via the View menu.","title":"Docks"},{"location":"ui/docks/#dock-widgets","text":"Dock widgets are key components of the graphical interface. Each one provides a specific view or control for fitting, plotting, or data inspection. Docks can be hidden, or restored via the View menu.","title":"Dock Widgets"},{"location":"ui/docks/#overview","text":"By default, the following dock widgets are available in each fitting tab: Dock Name Purpose Fit Formula Enter and edit the fitting equation Fit Results Display fit report and estimated parameters Manual Control Adjust parameters manually with sliders X/Y Data Inspect the loaded dataset in tabular form Plot Area Visualize raw data, fits, and diagnostics","title":"Overview"},{"location":"ui/docks/#1-fit-formula","text":"Allows symbolic definition of the model using a Python-like syntax. Formula must start with y = , e.g., y = a * x + b . Parameters are automatically extracted and synchronized with the Fit Options. Functions like exp , log , sin , abs , and physical constants can be used. Actions: Import or export formulas Open the Fit Options window Update formula dynamically with the fit mode (1D, 2D)","title":"1. Fit Formula"},{"location":"ui/docks/#2-fit-results","text":"Displays results after fitting: Best-fit values Confidence intervals Goodness-of-fit metrics (e.g., \u03c7\u00b2, R\u00b2) Updated live after each fit Hidden until a fit is completed","title":"2. Fit Results"},{"location":"ui/docks/#3-manual-control","text":"Provides sliders to control parameter values manually. Useful for visually exploring parameter space or preparing a good initial guess. Can be toggled from the toolbar. Automatically updates the plot in real time.","title":"3. Manual Control"},{"location":"ui/docks/#4-xy-data","text":"Displays the currently loaded dataset in table format. Adapts to data content (1D or 2D): Shows X , Y , and optionally Z , X_err , Y_err , Z_err . Allows user to inspect data before fitting. Automatically appears after loading a valid file.","title":"4. X/Y Data"},{"location":"ui/docks/#5-plot-area","text":"Central area for displaying: Raw data Fitted curve Residuals Confidence bands Decomposed components Interacts with toolbar toggles Automatically updated after data load or fit execution","title":"5. Plot Area"},{"location":"ui/docks/#managing-docks","text":"Docks can be moved, closed, or rearranged freely. Use View > Restore Default Layout to reset the layout. Visibility of individual docks can be toggled via the View menu.","title":"Managing Docks"},{"location":"ui/menus/","text":"Menus The menu bar at the top of the application provides structured access to data operations, session management, layout customization, and application tools. File Menu Load Data : Import a dataset from a .csv Unload Data : Clear current dataset Export Data : Save dataset as .csv Load Previous Data : Reopen recent files Exit : Quit the application Fits Menu New Fit : Create a new tab for an independent fitting session Close Fit : Remove the currently active fit tab View Menu Docks : Show or hide: Fit Formula, X/Y Data, Fit Results, Manual Control, Plot Restore Default Layout : Reset the arrangement of docks and toolbar.","title":"Menus"},{"location":"ui/menus/#menus","text":"The menu bar at the top of the application provides structured access to data operations, session management, layout customization, and application tools.","title":"Menus"},{"location":"ui/menus/#file-menu","text":"Load Data : Import a dataset from a .csv Unload Data : Clear current dataset Export Data : Save dataset as .csv Load Previous Data : Reopen recent files Exit : Quit the application","title":"File Menu"},{"location":"ui/menus/#fits-menu","text":"New Fit : Create a new tab for an independent fitting session Close Fit : Remove the currently active fit tab","title":"Fits Menu"},{"location":"ui/menus/#view-menu","text":"Docks : Show or hide: Fit Formula, X/Y Data, Fit Results, Manual Control, Plot Restore Default Layout : Reset the arrangement of docks and toolbar.","title":"View Menu"},{"location":"ui/overview/","text":"Interface Overview This section provides a general overview of the graphical user interface used for data fitting and analysis. The interface is composed of modular components, allowing users to efficiently load data, configure models, perform fits, and visualize results. Main Components Application Window The main application container. It manages the overall layout, including tabs, toolbars, menus, and dockable gcfpy.widgets. It also handles file operations, global settings, and shortcuts. Menus At the top of the application window, the menu bar provides access to core functionality: File: Load data from CSV files, create new tabs, or exit the application. Fits: Add or close fit tabs. View: Show or hide individual dock widgets (e.g., Fit Formula, X/Y Data), or restore the default layout. Help: Open the user guide, documentation, or version information. (Not added) Toolbar Located at the top of the application, the toolbar provides fast access to fitting and visualization tools such as : Confidence interval toggles (1D and 2D) Residual and decomposition views Data selection Data smoothing and weighting options Fit comparison mode and controls These options adapt depending on the current tab\u2019s mode (1D or 2D). Fit Tabs Each tab is an independent fitting session. Within a tab, users can: Load a dataset Enter a symbolic formula Select fitting method and options View results Tabs are isolated from each other. You can work on multiple models or datasets in parallel without interference. Docks Dockable widgets provide access to specialized features. These include: Fit Formula: Symbolic formula editor with parameter auto-detection Fit Control: Run the fit, inspect convergence and goodness of fit Fit Results: Shows the fitted parameters, errors, and statistics Manual Control: Allows manual adjustment of parameters with sliders and real-time updates to the fit. Plot: Displays data, fit curves, confidence bands, and other visual elements depending on user selection X/Y table: Table view of loaded dataset Plot Interaction Each plot window includes standard navigation controls (zoom, pan, reset). Additional overlays such as residuals or confidence bands are controlled via the toolbar or fitting options. Fit Modes: 1D vs 2D The interface adapts automatically to the dataset format: 1D Mode: Requires columns X and Y. Plots are simple curves with optional error bars and confidence bands. 2D Mode: Requires X, Y, and Z. Offers two strategies: Fit per Y: Apply a 1D fit model to each group of Y Fit Surface: Fit a global surface model Z = f(X, Y) These modes determine the available fit strategies and visual outputs. Layout Management The interface uses a fully dockable system: All widgets (formula, plot, data) can be moved or detached Panels can be hidden from the View menu Layout is saved automatically between sessions A default layout can be restored at any time This flexibility allows users to arrange the workspace according to their workflow and screen size.","title":"Overview"},{"location":"ui/overview/#interface-overview","text":"This section provides a general overview of the graphical user interface used for data fitting and analysis. The interface is composed of modular components, allowing users to efficiently load data, configure models, perform fits, and visualize results.","title":"Interface Overview"},{"location":"ui/overview/#main-components","text":"Application Window The main application container. It manages the overall layout, including tabs, toolbars, menus, and dockable gcfpy.widgets. It also handles file operations, global settings, and shortcuts. Menus At the top of the application window, the menu bar provides access to core functionality: File: Load data from CSV files, create new tabs, or exit the application. Fits: Add or close fit tabs. View: Show or hide individual dock widgets (e.g., Fit Formula, X/Y Data), or restore the default layout. Help: Open the user guide, documentation, or version information. (Not added) Toolbar Located at the top of the application, the toolbar provides fast access to fitting and visualization tools such as : Confidence interval toggles (1D and 2D) Residual and decomposition views Data selection Data smoothing and weighting options Fit comparison mode and controls These options adapt depending on the current tab\u2019s mode (1D or 2D). Fit Tabs Each tab is an independent fitting session. Within a tab, users can: Load a dataset Enter a symbolic formula Select fitting method and options View results Tabs are isolated from each other. You can work on multiple models or datasets in parallel without interference. Docks Dockable widgets provide access to specialized features. These include: Fit Formula: Symbolic formula editor with parameter auto-detection Fit Control: Run the fit, inspect convergence and goodness of fit Fit Results: Shows the fitted parameters, errors, and statistics Manual Control: Allows manual adjustment of parameters with sliders and real-time updates to the fit. Plot: Displays data, fit curves, confidence bands, and other visual elements depending on user selection X/Y table: Table view of loaded dataset","title":"Main Components"},{"location":"ui/overview/#plot-interaction","text":"Each plot window includes standard navigation controls (zoom, pan, reset). Additional overlays such as residuals or confidence bands are controlled via the toolbar or fitting options.","title":"Plot Interaction"},{"location":"ui/overview/#fit-modes-1d-vs-2d","text":"The interface adapts automatically to the dataset format: 1D Mode: Requires columns X and Y. Plots are simple curves with optional error bars and confidence bands. 2D Mode: Requires X, Y, and Z. Offers two strategies: Fit per Y: Apply a 1D fit model to each group of Y Fit Surface: Fit a global surface model Z = f(X, Y) These modes determine the available fit strategies and visual outputs.","title":"Fit Modes: 1D vs 2D"},{"location":"ui/overview/#layout-management","text":"The interface uses a fully dockable system: All widgets (formula, plot, data) can be moved or detached Panels can be hidden from the View menu Layout is saved automatically between sessions A default layout can be restored at any time This flexibility allows users to arrange the workspace according to their workflow and screen size.","title":"Layout Management"},{"location":"ui/toolbar/","text":"Toolbar The toolbar provides quick access to key actions for running fits, adjusting plots, and managing the visual interface. It remains visible at the top of the application window and adapts dynamically based on the current data or fit state. Fit Management Add to Comparison : Save the current fit to the comparison buffer. Toggle Comparison Mode : Display multiple saved fits on the same plot. These options are visible when a fit is active. This option is available for 1D and multi 1D fits and is not available for 2D fits. Plot Controls Enable or disable the following visual layers: 99% Confidence Band : Visualize uncertainty of the fit. Residuals : Plot the difference between data and model. Component Decomposition : Show each term in the model separately. 2D Confidence Contours : View parameter uncertainty in surface fits. These options are visible when a fit is active. Options are for for 1D fit. These options are not available for fits made with emcee . The 2D countour has not been integrated for the fit using scipy.odr . To see how these plots are made, examples can be found in the file examples/plot. Domain Selection Set X Range : Activate the Xmin/Xmax tool to restrict the domain used for fitting. For 1D fit. Preprocessing Options Smoothing : Apply a filter to the data before fitting. Weighting : Adjust the weight of each point during the fit. Toolbar Button Types Toggle Buttons Icon-based buttons that control visibility of features like confidence intervals or residuals. Buttons are highlighted when active and update the plot immediately. Dropdown Menus Used for mutually exclusive options: Smoothing : Gaussian (Savitzky-Golay) Moving Average None (default choice) Weighting : x error : error on the x data need x_err column in the .csv (odr fit only) y error : error on y data need y_err column in .csv file x and y error : error on the x an y data need x_err an y_err columns in the .csv (odr fit only) None Only avaible for 1D fit Dynamic Behavior Toolbar buttons are disabled by default . They are enabled automatically when: A dataset is successfully loaded A valid model is defined and a fit is performed Actions reflect their state in real-time (e.g., toggling residuals updates the plot immediately). Smoothing and weighting are mutually exclusive: only one method can be active per category at a time.","title":"Toolbar"},{"location":"ui/toolbar/#toolbar","text":"The toolbar provides quick access to key actions for running fits, adjusting plots, and managing the visual interface. It remains visible at the top of the application window and adapts dynamically based on the current data or fit state.","title":"Toolbar"},{"location":"ui/toolbar/#fit-management","text":"Add to Comparison : Save the current fit to the comparison buffer. Toggle Comparison Mode : Display multiple saved fits on the same plot. These options are visible when a fit is active. This option is available for 1D and multi 1D fits and is not available for 2D fits.","title":"Fit Management"},{"location":"ui/toolbar/#plot-controls","text":"Enable or disable the following visual layers: 99% Confidence Band : Visualize uncertainty of the fit. Residuals : Plot the difference between data and model. Component Decomposition : Show each term in the model separately. 2D Confidence Contours : View parameter uncertainty in surface fits. These options are visible when a fit is active. Options are for for 1D fit. These options are not available for fits made with emcee . The 2D countour has not been integrated for the fit using scipy.odr . To see how these plots are made, examples can be found in the file examples/plot.","title":"Plot Controls"},{"location":"ui/toolbar/#domain-selection","text":"Set X Range : Activate the Xmin/Xmax tool to restrict the domain used for fitting. For 1D fit.","title":"Domain Selection"},{"location":"ui/toolbar/#preprocessing-options","text":"Smoothing : Apply a filter to the data before fitting. Weighting : Adjust the weight of each point during the fit.","title":"Preprocessing Options"},{"location":"ui/toolbar/#toolbar-button-types","text":"","title":"Toolbar Button Types"},{"location":"ui/toolbar/#toggle-buttons","text":"Icon-based buttons that control visibility of features like confidence intervals or residuals. Buttons are highlighted when active and update the plot immediately.","title":"Toggle Buttons"},{"location":"ui/toolbar/#dropdown-menus","text":"Used for mutually exclusive options: Smoothing : Gaussian (Savitzky-Golay) Moving Average None (default choice) Weighting : x error : error on the x data need x_err column in the .csv (odr fit only) y error : error on y data need y_err column in .csv file x and y error : error on the x an y data need x_err an y_err columns in the .csv (odr fit only) None Only avaible for 1D fit","title":"Dropdown Menus"},{"location":"ui/toolbar/#dynamic-behavior","text":"Toolbar buttons are disabled by default . They are enabled automatically when: A dataset is successfully loaded A valid model is defined and a fit is performed Actions reflect their state in real-time (e.g., toggling residuals updates the plot immediately). Smoothing and weighting are mutually exclusive: only one method can be active per category at a time.","title":"Dynamic Behavior"},{"location":"user_guide/getting_started/","text":"Getting Started What is Graphical Curve Fit for Python ? Graphical Curve Fit for Python is a graphical tool designed for scientists, engineers, and students to explore curve fitting strategies interactively. Unlike libraries such as lmfit , emcee , or , scipy.odr this application is not a backend library. Instead, it offers a full graphical interface for visualising, adjusting, and comparing fits, especially when testing hypotheses, discovering models. Behind the scenes, the fitting itself is handled by scientific libraries: lmfit for least-squares optimization and model abstraction, scipy.odr for orthogonal distance regression, emcee for Bayesian sampling using MCMC. Graphical Curve Fit for Python acts as a frontend to these tools, with a focus on interactivity, model clarity, and visual output. Launching the Application Once installed (see Installation ), launch the application from your terminal: gcfpy You should see the main interface open within a few seconds. Default View on Launch Upon startup, the application opens with: A menu that allows you to load data, add tabs, and manage dock visibility, A toolbar toggle plots and views of the fits, apply x selection, activate compare dock. A Fit tab (you can open multiple), each representing an independent session, Two dock widgets : Data Plot : central plot of data and fitted models, Fit Formula : input area for model equations, Basic Workflow 1. Load a Dataset From the top menu, choose: File > Load Data Selecting a .csv file with at least X and Y columns is required. Optional columns such as Z , X_err , and Y_err are also supported. Some data are available in examples/data . Once loaded: The X/Y Data dock is populated. The data appears in the plot area. Fit actions are enabled. When data is loaded, two additional docks become visible: The Fit Control dock, which allows running the fit defined in the Fit Formula dock The X/Y Data dock, which displays the loaded dataset in table format In the toolbar , several options become available: Xmin/Xmax selection to restrict the fit to a specific x-range Smoothing tools to process noisy data Error handling that automatically enables weighting if X_err or Y_err columns are present in the data 2. Enter a Formula In the Fit Formula dock, enter your model using a Python-like syntax. For example: y = a * x + b The application automatically extracts the parameters ( a , b ) and updates the fitting configuration. You can use mathematical functions like sin , exp , log , abs , and more. Physical constants can also be added to the formula; see the list and syntax in Fit Formula Advanced options like importing/exporting formulas or editing them via GUI are also available. 3. Run the Fit To perform a fit: Click the Fit button on the toolbar, Or open the Fit Control dock to select: The fitting method ( Least Squares , ODR , MCMC ), Parameter settings and bounds, Weighting strategies. Once the fit is complete: The result appears in the Fit Results dock, The fitted curve In the toolbar, several options for different plots become available when the fit is made.","title":"Getting started"},{"location":"user_guide/getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"user_guide/getting_started/#what-is-graphical-curve-fit-for-python","text":"Graphical Curve Fit for Python is a graphical tool designed for scientists, engineers, and students to explore curve fitting strategies interactively. Unlike libraries such as lmfit , emcee , or , scipy.odr this application is not a backend library. Instead, it offers a full graphical interface for visualising, adjusting, and comparing fits, especially when testing hypotheses, discovering models. Behind the scenes, the fitting itself is handled by scientific libraries: lmfit for least-squares optimization and model abstraction, scipy.odr for orthogonal distance regression, emcee for Bayesian sampling using MCMC. Graphical Curve Fit for Python acts as a frontend to these tools, with a focus on interactivity, model clarity, and visual output.","title":"What is Graphical Curve Fit for Python ?"},{"location":"user_guide/getting_started/#launching-the-application","text":"Once installed (see Installation ), launch the application from your terminal: gcfpy You should see the main interface open within a few seconds.","title":"Launching the Application"},{"location":"user_guide/getting_started/#default-view-on-launch","text":"Upon startup, the application opens with: A menu that allows you to load data, add tabs, and manage dock visibility, A toolbar toggle plots and views of the fits, apply x selection, activate compare dock. A Fit tab (you can open multiple), each representing an independent session, Two dock widgets : Data Plot : central plot of data and fitted models, Fit Formula : input area for model equations,","title":"Default View on Launch"},{"location":"user_guide/getting_started/#basic-workflow","text":"","title":"Basic Workflow"},{"location":"user_guide/getting_started/#1-load-a-dataset","text":"From the top menu, choose: File > Load Data Selecting a .csv file with at least X and Y columns is required. Optional columns such as Z , X_err , and Y_err are also supported. Some data are available in examples/data . Once loaded: The X/Y Data dock is populated. The data appears in the plot area. Fit actions are enabled. When data is loaded, two additional docks become visible: The Fit Control dock, which allows running the fit defined in the Fit Formula dock The X/Y Data dock, which displays the loaded dataset in table format In the toolbar , several options become available: Xmin/Xmax selection to restrict the fit to a specific x-range Smoothing tools to process noisy data Error handling that automatically enables weighting if X_err or Y_err columns are present in the data","title":"1. Load a Dataset"},{"location":"user_guide/getting_started/#2-enter-a-formula","text":"In the Fit Formula dock, enter your model using a Python-like syntax. For example: y = a * x + b The application automatically extracts the parameters ( a , b ) and updates the fitting configuration. You can use mathematical functions like sin , exp , log , abs , and more. Physical constants can also be added to the formula; see the list and syntax in Fit Formula Advanced options like importing/exporting formulas or editing them via GUI are also available.","title":"2. Enter a Formula"},{"location":"user_guide/getting_started/#3-run-the-fit","text":"To perform a fit: Click the Fit button on the toolbar, Or open the Fit Control dock to select: The fitting method ( Least Squares , ODR , MCMC ), Parameter settings and bounds, Weighting strategies. Once the fit is complete: The result appears in the Fit Results dock, The fitted curve In the toolbar, several options for different plots become available when the fit is made.","title":"3. Run the Fit"},{"location":"user_guide/help/","text":"Getting Help If you have questions, suggestions, or encounter problems while using Graphical Curve Fit for Python, you can Start a discussion or report an issue on the project Git repository","title":"Getting help"},{"location":"user_guide/help/#getting-help","text":"If you have questions, suggestions, or encounter problems while using Graphical Curve Fit for Python, you can Start a discussion or report an issue on the project Git repository","title":"Getting Help"},{"location":"user_guide/install/","text":"Installation Prerequisites Graphical Curve Fit for Python requires Python 3.10 or higher . The following Python packages are needed for the core functionality: Package Version (min) Purpose numpy 1.20 Array handling pandas 1.3 Dataframes and CSV management matplotlib 3.5 Plotting PyQt5 5.15 Graphical interface lmfit 1.1 Non-linear least-squares fitting emcee \u2014 Bayesian inference via MCMC scipy 1.8 ODR fitting method sympy \u2014 Symbolic formulas corner \u2014 MCMC corner plots tqdm \u2014 Progress bars sip , pyqt5-sip \u2014 Required for PyQt bindings numdifftools \u2014 (optional) Numerical derivatives These packages are all available on PyPI and will be installed automatically with pip if you use the instructions below. Installing the Application To install the stable version from source: git clone https://github.com/gcfpy/gcfpy cd gcfpy pip install -e . This installs all required dependencies and enables you to run the application. To start it, run the following command in your terminal: gcfpy Developer Installation To install Graphical Curve Fit for Python in editable mode with development dependencies (formatting, tests, documentation): pip install -e .[dev,test,doc] This will include: black , ruff , isort , flake8 : Code formatting and linting pytest , pytest-qt , coverage : Unit and GUI testing mkdocs , mkdocs-material , mkdocstrings[python] , mkdocs-mermaid2-plugin , pymdown-extensions : Documentation generation You can also install subsets: pip install -e .[dev] # Dev tools only pip install -e .[test] # Testing tools only pip install -e .[doc] # Documentation tools only Additional Notes No Conda or pypi package is currently maintained. The application is graphical and needs a desktop environment. Example datasets can be found in the examples/data/ folder of the repository.","title":"Installation"},{"location":"user_guide/install/#installation","text":"","title":"Installation"},{"location":"user_guide/install/#prerequisites","text":"Graphical Curve Fit for Python requires Python 3.10 or higher . The following Python packages are needed for the core functionality: Package Version (min) Purpose numpy 1.20 Array handling pandas 1.3 Dataframes and CSV management matplotlib 3.5 Plotting PyQt5 5.15 Graphical interface lmfit 1.1 Non-linear least-squares fitting emcee \u2014 Bayesian inference via MCMC scipy 1.8 ODR fitting method sympy \u2014 Symbolic formulas corner \u2014 MCMC corner plots tqdm \u2014 Progress bars sip , pyqt5-sip \u2014 Required for PyQt bindings numdifftools \u2014 (optional) Numerical derivatives These packages are all available on PyPI and will be installed automatically with pip if you use the instructions below.","title":"Prerequisites"},{"location":"user_guide/install/#installing-the-application","text":"To install the stable version from source: git clone https://github.com/gcfpy/gcfpy cd gcfpy pip install -e . This installs all required dependencies and enables you to run the application. To start it, run the following command in your terminal: gcfpy","title":"Installing the Application"},{"location":"user_guide/install/#developer-installation","text":"To install Graphical Curve Fit for Python in editable mode with development dependencies (formatting, tests, documentation): pip install -e .[dev,test,doc] This will include: black , ruff , isort , flake8 : Code formatting and linting pytest , pytest-qt , coverage : Unit and GUI testing mkdocs , mkdocs-material , mkdocstrings[python] , mkdocs-mermaid2-plugin , pymdown-extensions : Documentation generation You can also install subsets: pip install -e .[dev] # Dev tools only pip install -e .[test] # Testing tools only pip install -e .[doc] # Documentation tools only","title":"Developer Installation"},{"location":"user_guide/install/#additional-notes","text":"No Conda or pypi package is currently maintained. The application is graphical and needs a desktop environment. Example datasets can be found in the examples/data/ folder of the repository.","title":"Additional Notes"}]}